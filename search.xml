<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title></title>
      <url>%2F2017%2F03%2F20%2F%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1NetworkManager%E4%B8%8Einterfaces%E5%86%B2%E7%AA%81%E7%9A%84%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[&nbsp;记录一次NetworkManager与interfaces冲突的解决&emsp;主机是ubuntu14.04，之前改过/etc/network/interfaces的配置内容（设置了静态ip），然后发现图形界面上的网络设置失效了，而且因为修改了interfaces之后还不能连接网络，ifconfig的时候不显示wlan0和eth0的信息，反而多了一个tun0-00。下面是一些解决的步骤： &emsp;首先，重新编辑interfaces文件和/etc/resolv.conf文件，使他们恢复默认设置，然后重启，失败。先解决eth0的问题吧。网线接上电脑，手动开启eth0： sudo ip link set eth0 up 或 sudo ifconfig eth0 up &emsp;再查看一下，ifconfig，如果没有ipv4地址，尝试： sudo dhclient eth0&emsp;然后ping一下同网段ip，失败的话，尝试nc命令&emsp;如果ICMP被禁了，使用nc命令或者telnet更适合，且可以探测端口是否开放,虽然DHCP端口是67，不过通常DHCP和DNS服务器是同一台机器，因此顺便测试53端口：nc -zv 192.168.1.1 67nc -zv 192.168.1.1 53&emsp;如果服务器的IP不是通过DHCP获取的动态IP，而是静态IP，则需要手动设置IP地址，使用ifconfig配置:sudo ifconfig eth0 192.168.1.105/24 gw 192.168.1.1或者sudo ip addr add 172.16.0.2/24 dev eth0sudo route add default gw 172.16.0.1 dev eth0配置完eth0之后，查看wlan0。&emsp;ubuntu上有两套管理网络的系统，一个是interfaces文件（网络设置由配置文件决定）和NetworkManager（网络设置由图形界面决定），它们二者之间只能使用一个，所以，在需要修改interfaces的时候（比如固定ip），要先把NetworkManager的服务屏蔽掉，service network-manager stop.之所以遇到这样的问题就是在修改interfaces之前没有对NetworkManager进行管理wlan0比较复杂，先尝试开启并连上网络1.. 打开无线网卡电源iwconfig wlan0 txpower on 或者 sudo ip link set wlan0 up列出区域内的无线网络iwlist wlan0 scan 或者 sudo iw dev wlan0 scan | less3.连接wifi假如wifi没有加密：sudo iw dev wlan0 connect [网络 SSID]假如是WEP加密：sudo iw dev wlan0 connect [网络 SSID] key 0:[WEP 密钥]假如是WPA或者WPA2加密的话，就比较麻烦了，需要借助wpasupplicant这个工具编辑_/etc/wpa_supplicant/wpa_supplicant.confnetwork={ssid=”[网络 ssid]“psk=”[密码]“priority=1} 重启网络 后台开启：sudo wpa_supplicant -i wlan0 -c /etc/wpa_supplicant/wpa_supplicant.conf 然后dhcp获取：sudo dhclient wlan0 或 sudo dhcpcd wlan0 如果正常的话，查看wlan0信息，输入iwconfig wlan0 启用无线网卡ifconfig wlan0 up 如果是用DHCP获取IP的，那么用dhclient 或dhcpcd获取ipdhclient wlan0 或 dhcpcd wlan0 &emsp;通过interfaces适合修改server版的linux，对于平常个人使用不方便，因为假如要连接新的wifi，每次都要新增配置文件，那么如何恢复原来的图形界面，也就是NetworkManager呢 首先要确保自己的图形界面设置没有修改过 比如/etc/dbus-1/system.d/org.freedesktop.NetworkManager.conf cat /etc/dbus-1/system.d/org.freedesktop.NetworkManager.conf&lt;!DOCTYPE busconfig PUBLIC“-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN”“http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd&quot;&gt;;&lt;policy user=”root”&gt; &lt;allow own=”org.freedesktop.NetworkManager”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.NetworkManager.PPP”/&gt; &lt;allow send_interface=”org.freedesktop.NetworkManager.SecretAgent”/&gt; &lt;!– Allow NM to talk to known VPN plugins; due to a bug in the D-Bus daemon, when a plugin is installed and the user immediately tries to use it, the VPN plugin’s rules aren’t always loaded into dbus-daemon. Those rules allow NM to talk to the plugin. Oops. Work around that by explicitly allowing NM to talk to VPN plugins here. –&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager.openconnect”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager.openswan”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager.openvpn”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager.pptp”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager.vpnc”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager.ssh”/&gt; &lt;!– Allow the custom name for the dnsmasq instance spawned by NM from the dns dnsmasq plugin to own it’s dbus name, and for messages to be sent to it. –&gt; &lt;allow own=”org.freedesktop.NetworkManager.dnsmasq”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager.dnsmasq”/&gt; &lt;/policy&gt; &lt;policy at_console=”true”&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.DBus.Introspectable”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.DBus.Properties”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.NetworkManager”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.NetworkManager.AccessPoint”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.NetworkManager.Connection.Active”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.NetworkManager.Device.Modem”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.NetworkManager.Device.Wired”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.NetworkManager.Device.Serial”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.NetworkManager.Device.Wireless”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.NetworkManager.Device”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.NetworkManager.DHCP4Config”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.NetworkManager.IP4Config”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.NetworkManager.VPN.Connection”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.NetworkManager.AgentManager”/&gt; &lt;deny send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.NetworkManager” send_member=”SetLogging”/&gt; &lt;deny send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.NetworkManager” send_member=”Sleep”/&gt; &lt;deny send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.NetworkManager” send_member=”sleep”/&gt; &lt;deny send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.NetworkManager” send_member=”wake”/&gt; &lt;/policy&gt; &lt;policy user=”whoopsie”&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.DBus.Introspectable”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.DBus.Properties”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.NetworkManager”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.NetworkManager.Connection.Active”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.NetworkManager.Device”/&gt; &lt;/policy&gt; &lt;policy context=”default”&gt; &lt;deny own=”org.freedesktop.NetworkManager”/&gt; &lt;deny send_destination=”org.freedesktop.NetworkManager”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.NetworkManager.Settings”/&gt; &lt;allow send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.NetworkManager.AgentManager”/&gt; &lt;deny send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.NetworkManager” send_member=”SetLogging”/&gt; &lt;deny send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.NetworkManager” send_member=”Sleep”/&gt; &lt;deny send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.NetworkManager” send_member=”sleep”/&gt; &lt;deny send_destination=”org.freedesktop.NetworkManager” send_interface=”org.freedesktop.NetworkManager” send_member=”wake”/&gt; &lt;deny own=”org.freedesktop.NetworkManager.dnsmasq”/&gt; &lt;deny send_destination=”org.freedesktop.NetworkManager.dnsmasq”/&gt; &lt;/policy&gt; 然后还有/etc/xdg/autostart/nm-applet.desktop： [Desktop Entry]Name=NetworkComment=Manage your network connectionsIcon=nm-device-wirelessExec=nm-appletTerminal=falseType=ApplicationNoDisplay=trueNotShowIn=KDE;X-GNOME-Bugzilla-Bugzilla=GNOMEX-GNOME-Bugzilla-Product=NetworkManagerX-GNOME-Bugzilla-Component=nm-appletX-GNOME-UsesNotifications=trueAutostartCondition=GNOME3 unless-session gnomeX-Ubuntu-Gettext-Domain=nm-applet网上有种说法：http://blog.csdn.net/cor\_twi/article/details/43836681但是按照这种做法没有用如果要用图形界面，到/etc/NetworkManager/nm-system-settings.conf下，把[ifupdown]managed=false（应该是修改了interfaces之后自动改成false的）中的false改成true&emsp;上述的方法能够重新使用有线和无线，但是也有留下不少的问题没有解决，比如开机的时候就要比平时等多2–3分钟（猜测是修改了配置之后通过NetworkManager管理网络的话是不会保留上一次工作的网络信息，然后导致本次开机重新加载），而且要通过图形界面配置网络的话，要在开机的时候输入：sudo service network-manager restart而且，此时的图形控制栏是缺少了一些功能的，比如关闭wifi，比如vpn配置，假如要关闭wifi，就通过sudo ifdown wlan0。假如是要配置vpn，也可以通过命令行实现，下面有两个方法：方法1：sudo pptpsetup –create testvpn –server 123.45.67.88 –username kk –password fku –encrypt –start&emsp;–create 后的是创建的连接名称，可以为任意名称; –server 后接的是vpn服务器的IP; –username 是用户名 –password 是密码，在这也可以没这个参数，命令稍后会自动询问。这样可以保证账号安全 –encrypt 是表示需要加密，不必指定加密方式，命令会读取配置文件中的加密方式 –start 是表示创建连接完后马上连接，如果你不想连，就不写连接：sudo pon vpnname查看状态：plog断开：sudo poff方法2：连接：~$ sudo nmcli -p c up id VPN-Green断开连接：~$ sudo nmcli -p c down id VPN-Green修改/etc/NetworkManagersystem-connections/VPN-Greenpassword-flags=0[vpn-secrets]password=*[connection]id=VPN-Green （名字）uuid=9b17f157-fb28-42bf-b092-d3e4a56682f1type=vpnpermissions=user:tomcat:;autoconnect=falsetimestamp=1444354237[vpn]service-type=org.freedesktop.NetworkManager.pptpgateway=a.sggjsq.comrequire-mppe=yesuser=*password-flags=0[vpn-secrets]password=*[ipv4]method=auto network-manager和/etc/network/interfaces的关系当系统内没有第三方网络管理工具（比如network-manager），那么就会默认使用interfaces配置文件的内容。当系统安装network-manager(桌面版默认安装)之后，network-manager默认接管系统网络配置，用network-manager的配置参数设置。如果用户安装network-manager后自己手动修改interfaces参数，network-manager就会自动停止对系统网络管理，改用interfaces配置。重启network-manager接管：123456sudo service network-manager stop #停止 nm 服务sudo rm/var/lib/NetworkManager/NetworkManager.state #移除 nm 的状态文件sudo vim /etc/NetworkManager/nm-system-settings.conf## 里面有一行：managed=true## 如果你手工改过 /etc/network/interfaces ，nm 会自己把这行改成：managed=false## 将 false 修改成 true 然后重新配置interfaces文件，恢复到默认：12auto loiface lo inet loopback 同时删除删除/etc/resolv.conf，最后1sudo service network-manager start 到这里基本完成了问题，但是你会发现，当重启nm之后，图标的一些选项内容变成不可选了，那么要怎么办呢？我们只要找到nm-applet服务并开启就可以了。ALT+F2查找nm-applet，点击开启，并加入自启动（rpm系是systemctl enable NetworkManager命令）。可是问题又来了，启动这个服务之后和前面的共存了，也就是说左面上同时出现了两个网络图标（假如你一直再开启一个服务又会多出来一个，如果你关闭nm服务，nm-applet也会消失，开启nm后nm-applet又会出现多个），怎么去掉这些多余的nm-applet呢？123pkill nm-appletsudo /etc/init.d/dbus restart #设置单个进程nm-applet --sm-disable或者快捷键开启 更新network-Manager：1234567从PPA更新network-managersudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BC8EBFE8在/etc/apt/sources.list最后加上deb http://ppa.launchpad.net/network-manager/trunk/ubuntu karmic maindeb-src http://ppa.launchpad.net/network-manager/trunk/ubuntu karmic mainsudo aptitude updatesudo aptitude safe-upgrade Server版本在Ubuntu Server版本中，因为只存有命令行模式，所以要想进行网络参数设置，只能通过修改配置文件 /etc/network/interfaces 。具体设置方法如下：(1) Ubuntu Server 修改 IP地址打开 /etc/network/interfaces：1sudo vim /etc/network/interfaces 加入以下语句：12345auto eth0iface eth0 inet static addressxxx.xxx.xxx.xxx #IP地址 netmask xxx.xxx.xxx.xxx #子网掩码 gateway xxx.xxx.xxx.xxx #网关 (2) Ubuntu Server 修改 DNS打开 /etc/resolv.conf1sudo vim /etc/resolv.conf 改为如下内容：123search localdomain #如果本Server为DNS服务器，可以加上这一句，如果不是，可以不加nameserver 172.16.3.4 #希望修改成的DNSnameserver 172.16.3.3 #希望修改成的DNS (3) Ubuntu Server 重启网络在rc.local里加入这个重启网络配置的命令：1sudo /etc/init.d/networking restart 更多ubuntu网络设置：https://wiki.ubuntu.com.cn/%E8%81%94%E7%BD%91#Network_Manager.EF.BC.88GNOME.EF.BC.89参考：http://blog.csdn.net/xinling1588/article/details/7037294 http://int32bit.me/2016/04/18/Linux%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E6%80%BB%E7%BB%93/ https://linux.cn/article-4015-1.html http://blog.chinaunix.net/uid-108431-id-4096909.html vpn设置和命令：http://blog.sina.com.cn/s/blog_630d9b440100fjpu.html （参照上面完成） http://wiki.ubuntu.org.cn/UbuntuManual:%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE\#.E9.85.8D.E7.BD.AE.E6.97.A0.E7.BA.BF.E7.BD.91.E5.8D.A1.28Wi-Fi.29.E6.8E.A5.E5.8F.A3 https://wiki.debian.org/zh\_CN/NetworkConfiguration http://www.cnblogs.com/xuanfengling/p/3410551.html http://blog.csdn.net/pkueecser/article/details/7165865 来源： https://www.gitbook.com/book/simonid/linux/edit#/edit/master/记录一次关于networkmanager和interfaces的问题.md?_k=qmiwfi]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F20%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux添加启动脚本]]></title>
      <url>%2F2017%2F03%2F20%2FLinux%E6%B7%BB%E5%8A%A0%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%2F</url>
      <content type="text"><![CDATA[本人使用的是ubuntu14.04 deb系 脚本方式&ensp;&ensp;&ensp;首先在/etc/init.d下新建一段脚本，假设名为demo.sh，赋予执行权限：chmod a+x,g+x demo.sh。 方法1：&ensp;&ensp;&ensp;假如要将这段脚本设置为自启动脚本，那么我们可以将其软链接到/etc/rcX.d目录下，比如ln -s /etc/init.d/demo.sh /etc/rc3.d/S100demo,这里的100是指启动的优先级，假如我们要设置不启动，就设置为K100demo。rc3.d是完全多用户模式123456rc0.d: 停机，eeprom OpenBoot状态,可以进入硬件维护模式,或关闭机器。rc1.d: 单用户模式，可以对系统进行软件维护rc2.d: 多用户模式，启动网络工作站服务。 (最后会启动dtlogin允许图形界面工作站)rc3.d: 多用户模式，启动网络服务器模式rc4.d: 安全模式rc6.d: 重启 方法2：&ensp;&ensp;&ensp;还是前面那段脚本内容，可以将它添加到/etc/init.d/rc.local文件内，加到语句：exit 0 前面才行。 方法3：&ensp;&ensp;&ensp;类似方法1，将/etc/init.d/demo.sh赋予执行权限之后，执行：1sudo update-rc.d demo.sh default 100 #自启动优先级为100 如果要卸载启动脚本：1sudo update-rc.d -f demo.sh remove 脚本之外的自启动方法 方法1：安装和执行rcconf：12sudo apt-get install rcconfsudo rcconf 还有功能更齐全的sysv-rc-conf:12sudo apt-get install sysc-rc-confsysv-rc-conf #运行设置 rpm系 脚本方式 deb系的脚本方式都适用于rpm,不过rpm系还有拓展方式： 方法1：1234567（1）chkconfig --level [0123456] [service name] [on|off] chkconfig --level 23 dhcp3-server off ----设定dhcp server服务在level2,3下关闭.（2）chkconfig --list 查看服务的自动开启状态（3）chkconfig --add 增加一个服务给chkconfig来管理,但是该服务必须在/etc/init.d内。 方法2：&ensp;&ensp;通过systemctl方式自启动，比如我们要设置network-manager自启：1systemctl enable NetworkManager 更多方法参考：http://blog.csdn.net/fu_wayne/article/details/38018825 顺便提一下bash启动脚本：123456789101112131415161718 /etc/profile /etc/bashrc ~/.bash_profile ~/.bashrc ~/.bash_logout /etc/profile 和 ~/.bash_profile 是在启动一个交互登陆shell的时候被调用。/etc/bashrc 和 ~/.bashrc 是在一个交互的非登陆shell启动的时候被调用。~/.bash_logout 在用户注销登陆的时候被读取用户登录时，bash先自动执行系统管理员建立的全局登录script ： /ect/profile 然后bash在用户起始目录下按顺序查找三个特殊文件中的一个： /.bash_profile、 /.bash_login、 /.profile， 但只执行最先找到的一个。因此，只需根据实际需要在上述文件中加入命令就可以实现用户登录时自动运行某些程序 参考：http://jiangzhi2013.blog.51cto.com/7150666/1293877http://astute11.blog.51cto.com/4404646/1315587深入地理解linux启动浅析 Linux 初始化 init 系统，第 2 部分: UpStart]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux资料链接]]></title>
      <url>%2F2017%2F03%2F17%2FLinux%E8%B5%84%E6%96%99%E9%93%BE%E6%8E%A5%2F</url>
      <content type="text"><![CDATA[Linux资料 Linux C系列Linux内核里的“智能指针” Linux运维系列 Linux服务器系列frp内网穿透 Linux命令系列学习awkLINUX SHELL脚本攻略笔记[速查] Linux软件工具系列GitHub 加速最佳实践 Linux发行版系列]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[单个git工具配置多个代码托管账号]]></title>
      <url>%2F2017%2F03%2F16%2F%E5%8D%95%E4%B8%AAgit%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E8%B4%A6%E5%8F%B7%2F</url>
      <content type="text"><![CDATA[单个git工具配置多个代码托管账号 点击这里跳转到末尾&ensp;&ensp;&ensp;&ensp;最近在使用hexo的时候遇到了一个麻烦，本人平时用两台电脑，ubuntu和windows，在ubuntu上已经建立了一个hexo项目（基于github），然后想再windows上也能写hexo博客，但是这样就要反复地git pull,(更重要的是这样做要把整个hexo根目录加载到仓库。假如只是文章上传到仓库以达到多设备同步，那么就不能多设备定制主题)。如果想要用git同步多设备间的同一hexo博客可以参考这里参考2加上这个插件会使git同步hexo更方便，可以备份整个博客，包括你的主题，可以备份到任何git的服务器，github，gitcafe都没有问题https://github.com/coneycode/hexo-git-backup.git &ensp;&ensp;&ensp;&ensp;为了避免麻烦，可以使用oschina账号或者另外一个github账号也发布一个博客。但是在win上的git工具之前已经配置了github账号了，怎么设置多账号不冲突？首先取消之前的全局配置:12git config --global --unset user.namegit config --global --unset user.email ssh秘钥生成：1ssh-keygen -t rsa -C &quot;email&quot; 添加ssh key：1ssh-add -K ~/.ssh/id_rsa 删除key方法：1ssh-add -D 查看key设置 123ssh-add -l``` 新建ssh config文件：&lt;br/&gt; vim ~/.ssh/config config文件格式：123456789101112# Default github user(A@mail.com),注意User项直接填git，不用填在github的用户名Host A.github.com #自定义 HostName github.com#固定 User git #自定义 IdentityFile ~/.ssh/id_rsa_github_A# second user(B@mail.com)# 建一个gitlab别名，新建的帐号使用这个别名做克隆和更新Host A.github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa_github_B 如果不按照格式设置，就会出现：1ERROR: Permission to two/two.github.com.git denied to one. windows下的ssh秘钥和公钥也可以在git客户端上的~/.ssh目录找到&ensp;&ensp;&ensp;&ensp;因为ssh 客户端是通过类似:git@github.com:one/one.github.com.git这样的 git 地址中的 User 和 Host 来识别使用哪个本地私钥的。&ensp;&ensp;&ensp;&ensp;很明显，如果 User 和 Host 始终为 git 和 github.com，那么就只能使用一个私钥。&ensp;&ensp;&ensp;&ensp;所以需要上面的方式配置，每个账号使用了自己的 Host，每个 Host 的域名做 CNAME 解析到 github.com，这样 ssh 在连接时就可以区别不同的账号了测试：1234ssh -T git@github.com # 测试one ssh连接#Hi ***! You&apos;ve successfully authenticated, but GitHub does not provide shell access.ssh -T git@two.github.com # 测试two ssh连接#Hi ***! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 在各自账号中配置：1234git config user.name &quot;name&quot; # __name__ 例如 onegit config user.email &quot;email&quot;git config --list #检测配置 也可以：1234git remote add github A.github.com(输入的是config文件的Host选项) git@github.com:username/project.gitrepo init -u ssh://A@github.com -b branch#push的时候到对应的hostgit push A.github.com master 如果push的时候遇到：1warning: push.default is unset; its implicit value is changing in Git 2.0 from ‘matching’ to ‘simple’. To squelch this messageand maintain the current behavior after the default changes, use… 推荐使用：1git config --global push.default simple 假如clone没有问题，push的时候总是报错:1error: The requested URL returned error: 403 while accessing xxx 解决：修改 repo/.git/config 里面的url，把https地址替换为ssh就好了比如：1url=https://MichaelDrogalis@github.com/derekerdmann/lunch_call.git 替换为： 1url=ssh://git@github.com/derekerdmann/lunch_call.git 参考：http://tmyam.github.io/blog/2014/05/07/duo-githubzhang-hu-she-zhi/http://memoryboxes.github.io/blog/2014/12/07/duo-ge-gitzhang-hao-zhi-jian-de-qie-huan/http://www.imooc.com/article/7419http://yyblog.mocoer.com/2014/08/25/%E5%A4%9Agithub%E8%B4%A6%E5%8F%B7SSH%20key%E5%88%87%E6%8D%A2%E4%BD%BF%E7%94%A8/ 知乎上关于hexo多设备发布的讨论：https://www.zhihu.com/question/21193762]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo多仓库部署以及DNS分流]]></title>
      <url>%2F2017%2F03%2F16%2Fhexo%E5%A4%9A%E4%BB%93%E5%BA%93%E9%83%A8%E7%BD%B2%E4%BB%A5%E5%8F%8ADNS%E5%88%86%E6%B5%81%2F</url>
      <content type="text"><![CDATA[hexo多仓库部署以及DNS分流参考原文 hexo可以搭配github page搭建博客，但是github在国内的访问速度有限，我们可以考虑将hexo项目同时部署到oschina或者coding这些国内代码托管平台，通过DNSPod分流访问。要发布到代码托管平台，首先安装组件:1npm install hexo-deployer-git –save 在根目录配置文件下修改deploy,格式：12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] 参数描述：123repo 库(Repository)地址branch 分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测message 自定义提交信息 (默认为 Site updated: &#123;&#123; now(’YYYY-MM-DD HH:mm:ss’) &#125;&#125;) 如果是发布到多个平台：12345deploy:- type: git repo: &lt;repository url&gt;,[branch]- type: git repo: &lt;repository url&gt;,[branch] 其中，repositories（仓库）的地址有两种形式：第一种是https，类似1https://github.com/xyzardq/xyzardq.github.io.git 第二种是SSH，类似1git@github.com:xyzardq/xyzardq.github.io.git &ensp;&ensp;&ensp;&ensp;这两种仓库地址有什么区别呢？https是在部署时直接通过https协议push到对应的repositories，所以在push的时候需要输入仓库所对应的代码托管平台的账号密码。而SSH是在部署时用云端的公匙解锁本地的私匙，如果对应就直接push到对应的repositories，从而不用输入账户密码。本人比较推荐用SSH，毕竟不用输入密码比较方便。 DNS分流注册DNSPod：DNSPod&ensp;&ensp;&ensp;&ensp;现在，我们已经把Blog部署到了两个以上的平台上，那么，怎样才能根据访客不同的线路类型解析到不同的page上呢？这时就需要域名的DNS解析分流了。据我所知，目前DNSPod和cloudxds都支持DNS分流。DNSPod的免费版就支持DNS解析分流，但是缺点是免费版显性转址需要网站正常代理满30天….30天过去黄花菜都凉了，不过CNAME不受此限制。cloudxds的免费版号称DNSPod的收费版，但是缺点是没备案的域名用不了…所以如果是没备案的域名只能使用DNSPod了。下面以DNSpod为例。 添加CNAME记录 添加要解析的域名ps:填写的域名不要带www前缀 添加CNAME记录由于我们要进行DNS分流解析，所以一般来说需要添加两条以上的CNAME记录，下面以分为国外和国内两条线路为例ps:除了国外和国内，DNSPod还提供电信移动联通等运营商和谷歌百度等搜索引擎的线路提供修改NS记录 什么是NS记录？ NS记录（name server）即域名服务器记录，用于指定该域名由哪个 DNS 服务器进行域名解析。注册域名时，总会有默认的 NS 记录。 ps:如果是在DNSPod注册的域名，请跳过此步。 记下DNSPod的域名服务器 DNSPod的域名服务器存储在控制台的DNS记录中，默认为12f1g1ns1.dnspod.netf1g1ns2.dnspod.net 修改所用域名注册商的域名服务器 登录所用域名的域名注册商，进入DNS管理，将域名服务器（有的注册商为DNS记录中的NS记录）修改为DNSPod的域名服务器 测试DNS解析是否生效 打开Dns检测|Dns查询- 站长工具，输入你的域名，选择CNAME类型，检测。如果国内国外的响应IP分别为你设置的两个记录值，则DNS分流设置成功 另附上参考：同时将博客部署在Github和Gitcafe上，并通过DNSPOD分流使用 DNSPod 解决 GoDaddy 域名解析不稳定的问题]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux创建共享目录]]></title>
      <url>%2F2017%2F03%2F16%2FLinux%E5%88%9B%E5%BB%BA%E5%85%B1%E4%BA%AB%E7%9B%AE%E5%BD%95%2F</url>
      <content type="text"><![CDATA[Linux创建共享目录如果你是管理员，想给其他人针对某个目录的权限，那么就要划定一个有一定权限的用户组和该目录绑定先创建目录和用户组:12$ sudo mkdir -p /var/www/reports/$ sudo groupadd project 将对目录 /var/www/reports/ 有写权限的用户添加到 project 组中1$ sudo usermod -a -G project tecmint 上面命令使用到的标志和参数是：1234-a – 将用户添加到增补组中。-G – 指定组名。project – 组名。tecmint – 已有的用户名。 递归权限赋予:12$ sudo chgrp -R project /var/www/reports/$ sudo chmod -R 2775 /var/www/reports/ 解释下上面 chmod 命令中的 2775：12342 - 打开 setGID 位，意味着新创建的子文件继承与目录相同的组，新创建的子目录继承父目录的 setGID 位。7 - 为所有者提供 rwx 权限。7 - 给组 rwx 权限。5 - 为其他人提供 rx 权限。 可以使用下面的命令创建更多的系统用户并将它们添加到目录组中：123sudo useradd -m -c &quot;Aaron Kili&quot; -s/bin/bash -G project aaronkilik$ sudo useradd -m -c &quot;John Doo&quot; -s/bin/bash -G project john$ sudo useradd -m -c &quot;Ravi Saive&quot; -s/bin/bash -G project ravi 接着创建每个用户存储他们项目报告的子目录123$ sudo mkdir -p /var/www/reports/aaronkilik_reports$ sudo mkdir -p /var/www/reports/johndoo_reports$ sudo mkdir -p /var/www/reports/ravi_reports]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[django之mvc]]></title>
      <url>%2F2017%2F03%2F15%2Fdjango%E4%B9%8Bmvc%2F</url>
      <content type="text"><![CDATA[django之mvc推荐：http://morningchen.com/tags/Django/ MVC(Model View Controller 模型-视图-控制器)是一种web架构模型，将业务逻辑、模型数据、用户界面分离，前端开发只要负责页面部分，后端开发只要负责后台管理和数据库。model:将客观实物抽象为对象，由类产生多种方法。view:视图，呈现的内容基于model，也负责收集用户输入。controller：model和view之间的媒介。MVC是单向的，过程：1234浏览器发起请求controller和model交互获取数据controller调用viewview渲染数据返回 开发web需要的组件： 数据库的对象关系映射（ORM,Object-Relation Maping）&lt;br/&gt; 动态内容管理的模板系统&lt;br/&gt; 丰富自动化的管理界面&lt;br/&gt; 模型图：12345678910111213优点： 可以为一个模型在运行的同时建立和使用多个视图 视图与控制器的可插拔性 模型的可移植性 潜在的框架结构缺点： 增加了系统结构和实现的复杂性 视图与控制器连接过于紧密 视图对模型数据的低效率访问 高级界面工具不支持MVC模式 Django框架中的 MVC实现方式：123 当URL被请求 ➜ 调用指定的Python方法 ➜ 通过业务逻辑(model)处理 ➜ 经过模板(template) ➜ 呈现页面(view)这种实现方式在Django中称为 MVT(Model-View-Template) 参考链接:http://morningchen.com/2015/04/08/Django-MVC/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo主题定制2]]></title>
      <url>%2F2017%2F03%2F15%2Fhexo%E4%B8%BB%E9%A2%98%E5%AE%9A%E5%88%B62%2F</url>
      <content type="text"><![CDATA[hexo主题定制2 博主推荐：http://moxfive.xyzhttp://gaomf.cnhttp://www.xyzardq.comhttp://www.kyfxbl.com/2015/07/25/%E4%BC%98%E5%8C%96hexo/ 主题介绍：Yelee:http://moxfive.coding.me/yelee/ 设置代码高亮在反引号后面紧跟着语言名称就可以了，比如c语言1234int main()&#123; printf("hello word\n"); return 0;&#125; 在反引号后面加上c 添加单独页面，比如自我介绍&ensp;&ensp;首先在根目录下的public/categories目录下找到相关目录，然后再添加md文件，在到主题目录下找到配置文件，在其中的menu下自定义选项，注意路径一定要正确 自定义侧边栏自我介绍&ensp;&ensp;相关文件在left-col.ejs下，比如我要添加两段文字,可以：12345&lt;hgroup&gt; &lt;h1 class="header-author"&gt;&lt;a href="/" class="alluraregular"&gt;&lt;%=theme.author%&gt;&lt;/a&gt;&lt;/h1&gt; &lt;/hgroup&gt; &lt;p class="header-subtitle"&gt;纵有疾风起 | 人生不言弃&lt;/p&gt; 相关的样式文件是main.styl 自定义标签相关样式文件是tagcloud.styl 添加RSS插件1npm install hexo-generator-feed --sava 然后到主题目录下的配置文件中的subnav选项下新增选项，比如：12subnav: rss:&quot;/atom.xml&quot; hexo g之后可以在public下看到新增的atom.xml 新增目录1hexo new page ... :新增目录 在/themes/yilia/layout/_partial/article.ejs里修改。将下面代码放在&lt;%- post.content %&gt;之上这一段内容参考自：参考123456&lt;% if(post.toc == true)&#123; %&gt;&lt;div id="toc" class="toc-article"&gt; &lt;strong class="toc-title"&gt;文章目录&lt;/strong&gt;&lt;%- toc(post.content, &#123;list_number: false&#125;) %&gt;&lt;/div&gt;&lt;% &#125; %&gt; 这其中加了一个判断，默认是不加目录的（当然你也可以改成post.toc == false，这样默认就是添加目录的情况啦），如果想在文章中使用目录的话，可以在 front-matter里加上 toc: true 即可. 像这样子：12345title: &quot;在Hexo中给文章加目录(Table Of Contents)&quot;date: 2015-07-15 22:40:42tags: [Hexo]toc: true--- 修改目录样式：/themes/yilia/source/css/_partial/article.styl中的末尾加上1234567891011121314151617181920212223242526.toc-article &#123; background: #eee; margin: 0 0 0 .5em; padding: 1em&#125;.toc-article strong &#123; padding: .3em 0&#125;#toc &#123; line-height: 1.6em; font-size: .8em; float: right&#125;#toc .toc &#123; padding: 0&#125;#toc .toc li &#123; list-style-type: none&#125;#toc ol &#123; margin-left: 0&#125;#toc .toc-child &#123; padding-left: 1.5em&#125; &ensp;&ensp;&ensp;&ensp;第一段的toc-article指定了目录整个&lt;div&gt;的背景色、边框色、倒角半径、各种间距以及最大的宽度。注意这里最好指定目录的最大宽度，我将其设为了28%，也就是文章正文那个框的宽度的28%，也可以设为一个固定的长度，比如在笔记本电脑上16em就是个不错的宽度，但为了能适配各种不同尺寸的屏幕，最好还是设置为百分比。如果不指定最大宽度，遇到比较长的标题时，生成的目录会非常难看。这个最大宽度的设置是我在网上其他添加目录的方法中没有见到的。&ensp;&ensp;&ensp;&ensp;第二段的toc-title指的就是“文章目录”那四个字，这四个字要比其他字大一些，将其字号设为其他字的120%。&ensp;&ensp;&ensp;&ensp;第三段的#toc.toc指定了目录列表的一些细节，将font-size设为0.9em会让目录的字比文章的字稍小一些。最后的.toc-child指定了二级目录的缩进量。&ensp;&ensp;&ensp;&ensp;再次生成页面，应该已经可以显示比较美观的目录 常见错误解决：参考12FATAL (unknown path) [Line 7, Column 533] Error: Unable to call `now`, which is undefined or falsey Template render error: (unknown path) [Line 7, Column 533] 错误原因：由于文章中有类似now()的结构，Hexo编译时误认为是now函数，结果找不到函数就报错了解决：将now( )的小括号通过&amp;#40; &amp;#41;进行转换。 部分插件加载失败：1ERROR Plugin load failed:hexo-generator-json-content 解决：升级nodejs hexo d报错：终极解决方案1.删除根目录下的.deploy_git文件夹2.在根目录运行hexo clean3.修改根目录下的_config.yml后运行hexo deploy部署到云端 hexo g错误:个人认为最大原因是配置文件出错另附参考：http://www.voidcn.com/blog/chwshuang/article/p-6178796.htmlhttps://xuanwo.org/2014/08/14/hexo-usual-problem/ 添加站点小图标主题目录下/source中添加图片 添加文章目录配置中启用：12345toc: on: true list_number: true #开启标题前序号 max_depth: 3 #目录最大级数，可选1-6 nowrap: false #标题不换行 如果要在某个文章中关闭目录，那么在md文件开头加上：12toc ：false #关闭目录toc_list_number: false #隐藏目录序号]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux-Command]]></title>
      <url>%2F2017%2F03%2F14%2FLinux-Command%2F</url>
      <content type="text"><![CDATA[Linux Command 查找相同的文件：首先要下载fdupes工具:123sudo apt-get install fdupes# yum install fdupes# dnf install fdupes //fedora22之后 12345fdupes directory/ 查找目录下相同的文件fdupes directory/ -r -d 递归查找出重复名的文件，并且删除掉重复的，删除哪个文件可以根据编号确定，也可以设置范围，注意如果如果只是名字相同内容不同会导致误删。下面是别的参数：-S：显示重复文件的大小-f：忽略掉每个匹配集中的首个文件 通过名字查找进程ID1ps aux | awk &apos;/name/ &#123;print $2&#125;&apos; 以适合的方式(显示m或k…)输出当前目录下的各个子目录大小1du -h --max-depth=1 使用dd备份硬盘1sudo dd -f=/dev/sda of=/media/disk/backup/sda.backup 创建指定大小的文件1dd if=/dev/zero of=aa.txt bs=1M count=1 找到默认网关1netstat -rn | grep UG | tr -s &quot; &quot; | cut -d&quot; &quot; -f2 scp远程复制格式：scp 参数 原路径 目标路径参数：-v —详细显示输出的具体情况 -r —递归复制整个目录1234567891011121314151617复制文件：scp local_file remote_username@remote_ip:remote_folder 或者 scp local_file remote_username@remote_ip:remote_file 或者 scp local_file remote_ip:remote_folder 或者 scp local_file remote_ip:remote_file注解：第1,2个指定了用户名，命令执行后需要输入用户密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名 ;第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名;复制目录：scp -r local_folder remote_username@remote_ip:remote_folder 或者 scp -r local_folder remote_ip:remote_folder 通过搜寻数据库快速查找文件和目录，加上-r引入正则 find查找格式：find [PATH] [option] [action]12345和时间相关的option：-mtime n ：n 为数字，意义为在 n 天之前的『一天之内』被更动过内容的档案； -mtime +n ：列出在 n 天之前(不含 n 天本身)被更动过内容的档案档名； -mtime -n ：列出在 n 天之内(含 n 天本身)被更动过内容的档案档名。 -newer file ：file 为一个存在的档案，列出比 file 还要新的档案档名 1234567和当单权限还有名称相关的option： -uid n ：n 为数字，这个数字是用户的账号 ID，亦即 UID -gid n ：n 为数字，这个数字是组名的 ID，亦即 GID -user name ：name 为使用者账号名称！例如 dmtsai -group name：name 为组名，例如 users ； -nouser ：寻找档案的拥有者不存在 /etc/passwd 的人！ -nogroup ：寻找档案的拥有群组不存在于 /etc/group 的档案 将deb转到rpm1alien -r -c file.deb curl下载命令下载单个文件:12curl urlcurl -C url //断点续传 -o/-O选项将下载的文件重命名并保存到指定位置：12curl -o a.txt urlcurl -O url1 -O url2 //同时下载多个文件 限制下载速度:1curl --limit-rate 200k -O url 从FTP服务器上下载或上传文件:12curl -u ftpuser:ftppwd -O url //下载curl -u ftpuser:ftppwd -T filename url//下载 传递请求:12345678//GETcurl -u username https://api.github.com/user?access_token=XXXXX//POSTcurl -u username --data &quot;param1=value1&amp;param2=value&quot; https://api.github.com//如果post的数据中带特殊字符要进行转义，--data-urlencode选项可以做到curl --data-urlencode &quot;value 1&quot; http://hostname.com//也可以指定一个文件，将该文件中的内容当作数据传递给服务器端curl --data @filename https://github.api.com/authorizations 这个命令还可以设置代理等等功能 sftp传输连接上服务器:1sftp rserver_name@server_ip 登录后可以后续操作：1234sftp&gt; ls #list directory sftp&gt; pwd #print working directory on remote hostsftp&gt; lpwd #print working directory on local hostsftp&gt; mkdir uploads #create a new directory 上传：123sftp&gt; put -r file//要保留修改时间、访问时间以及被传输的文件的模式，请使用 -p 标志sftp&gt; put -pr file 下载：1sftp&gt; get -r file 退出：123sftp&gt; bye或者sftp&gt; exit 找出最近修改的N个文件1ls -1t | head -n N 显示所有使用tcp和udp进程1netstat -plantu 按照后缀查找文件12//比如查找cpp和h后缀find . regex &apos;.*\(h\|cpp\)&apos; 输出文件指定行范围内容默认head命令打印其相应文件的开头10行1head -n 20 file | tail //显示10到20行内容 另外再提一下head其他用途：相关参数：1234-q :隐藏文件名-v ：显示文件名-c N：显示前N个字节 比如head -c 20 file。另外如果是head -c -20 file就是显示除了最后20个字节以外的内容-n N：显示前N行 head -n -10 file显示最后10行内容 参考：http://blog.csdn.net/qwe6112071/article/details/50806734https://linux.cn/article-8253-1.html?utm_source=weibo&amp;utm_medium=weibo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css3学习1]]></title>
      <url>%2F2017%2F03%2F13%2Fcss3%E5%AD%A6%E4%B9%A01%2F</url>
      <content type="text"><![CDATA[CSS3学习1imooc学习笔记首先放出一张盒子模型： 边框圆角效果border-radius比如：border-radius:10px;所有角都使用半径为10px的圆角boder-radius:5px 4px 3px 2px;四个半径值分别是左上角、右上角、右下角和左下角，顺时针顺序不仅可以使用px作为单位，也可以用百分比或者em，但是兼容性不好 圆的效果实心上半圆：方法：把高度(height)设为宽度（width）的一半，并且只设置左上角和右上角的半径与元素的高度一致（大于也是可以的）。123456div&#123; height:50px;/*是width的一半*/ width:100px; background:#9da; border-radius:50px 50px 0 0;/*半径至少设置为height的值*/ &#125; 实心圆：方法：把宽度（width）与高度(height)值设置为一致（也就是正方形），并且四个圆角值都设置为它们值的一半。如下代码：123456div&#123; height:100px;/*与width设置一致*/ width:100px; background:#9da; border-radius:50px;/*四个圆角值都设置为宽度或高度值的一半*/ &#125; 左半圆：12345div&#123; height:100px; width:50px; background:#9da; border-radius:50px 0 0 50px; &#125; 边框阴影box-shadowbox-shadow: X轴偏移量 Y轴偏移量 [阴影模糊半径] [阴影扩展半径] [阴影颜色] [投影方式];注意：inset 可以写在参数的第一个或最后一个，其它位置是无效的。元素设置外阴影：123.box_shadow&#123; box-shadow:4px 2px 6px #333333; &#125; 元素设置内阴影：123.box_shadow&#123; box-shadow:4px 2px 6px #333333 inset; &#125; 添加多个阴影：123.box_shadow&#123; box-shadow:4px 2px 6px #f00, -4px -2px 6px #000, 0px 0px 12px 5px #33CC00 inset;&#125; 1.阴影模糊半径和阴影扩展半径的区别阴影模糊半径：此参数可选，只能是正值，如果为0，表示阴影不具有模糊效果，其值越大阴影边缘就越模糊阴影扩展半径：此参数可选，其值可以是正负值，如果为正，则整个阴影都延展扩大，反之值为负数就缩小 2.x轴偏移量和Y轴偏移量值可以设置为负数:box-shadow: X轴偏移量 Y轴偏移量 [阴影模糊半径] [阴影扩展半径] [阴影颜色] [投影方式];x轴偏移量和y轴偏移量值可以设置为负数：12345.boxshadow-outset&#123; width:100px; height:100px; box-shadow:-4px 4px 6px #666;&#125; 效果：Y轴偏移量为负数：12345.boxshadow-outset&#123; width:100px; height:100px; box-shadow:4px -4px 6px #666;&#125; 边框应用图片border-image格式：1background:url(xx.jpg) 10px 20px no-repeat; 12345#border-image&#123; background:#F4FFFA; width:210px; height:210px; border:70px solid #ddd; border-image:url(borderimg.png) 70 repeat &#125; repeat的意思就是重复，目前因为是刚好被整除，效果看不出来。如果改下DIV的宽高，再来看重复的效果：边角部分为裁掉了，可见repeat就是一直重复，然后超出部分剪裁掉，而且是居中开始重复。 Round 参数：Round可以理解为圆满的铺满。为了实现圆满所以会压缩（或拉伸）；1234567891011#border-image &#123; width:170px; height:170px; border:70px solid; border-image:url(borderimg.png) 70 round; &#125; streth是拉伸的意思：1border-image:url(...) 70 stretch 注意：Chrome下，中间部分也会被拉伸，webkit浏览器对于round属性和repeat属性似乎没有区分，显示效果是一样的。Firefox 26.0 下是可以准确区分的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[c中的void]]></title>
      <url>%2F2017%2F03%2F13%2Fc%E4%B8%AD%E7%9A%84void%2F</url>
      <content type="text"><![CDATA[c中的void假如我们定义了一个变量(比如int a)，然后在后面没有使用，那么在编译的时候就会显示warning，要消除这个warning，我们可以用这样的格式：a=a;但是现在更流行的写法是：(void)a;void型指针可以指向任意类型数据，也可以用任意数据类型指针对void指针赋值，比如函数：void memset(voidbuffer,intc,size_tnum); 又比如:12345int *a;void *b;b=a; //truea=b; //errora=(int*)b; //true ANSIC标准中不能对void指针进行算术运算，比如b++，但是在GNU中却可以，因为GNU会认为void和char一样任何类型的指针都可以显式转换为void类型指针，且不会丢失数据任何表达式均可转换为 void，但 void 类型的表达式不能强制转换为其他类型。 例如，带有 void 返回类型的函数不能将其返回值强制转换为另一类型。 顺便提合法的类型强制转换：|目标类型 |可能的源||整型 |整数类型或浮点类型，或者指向对象的指针|浮点 任何算术类型指向对象的指针或 (void ) 任何整数类型、(void )、指向对象的指针或函数指针函数指针 任何整数类型、指向对象的指针或函数指针结构、联合或数组 无Void 类型 任何类型 最后要指明：如果函数没有返回值或参数，一定要声明为void类型函数或者形参]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[网络设备及协议]]></title>
      <url>%2F2017%2F03%2F13%2F%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E5%8F%8A%E5%8D%8F%E8%AE%AE%2F</url>
      <content type="text"><![CDATA[网络设备及协议MAC地址分类： 单播MAC地址：单播MAC地址唯一标识以太网上的一个终端，该地址固化在硬件(如网卡)内部。 组播MAC地址：首字节最后一位为1(通常以0x01开头)的MAC地址，标志一组设备。 广播MAC地址：48位全1的MAC地址，标志本网段内所有设备。网络中按照大字节序传输报文(即先传输高字节)，而字节内先传输低位比特。因此，若发送的首位比特为0就是单播，否则为组播或广播。MAC地址按生存期也可分为： 动态MAC地址：交换机在网络中通过数据帧学习到，有老化时间，MAC地址和端口的对应关系会随着设备所连的交换机的端口的变化而变化。交换机关电重启后会消失，需重新学习。 静态MAC地址：通过配置产生，不会被老化，MAC地址和端口的对应关系始终不变，但交换机关电重启后也会消失，需重新配置。 永久MAC地址：通过配置产生，不会被老化，MAC地址和端口的对应关系始终不变，且交换机关电重启后也不会消失。根据OSI模型，从下到上进行阐述： 集线器（Hub）：&ensp;&ensp;对于物理层，就是将网线集中到一起的设备，以太网集线器(HUB)从任一端口收到以太网数据帧后，都会将该帧广播到其它所有端口，如果不同端口连接的设备同时传输数据会引起冲突，故其冲突域和广播域是所有端口，既不能隔离冲突域也不能隔离广播域。 冲突域和广播域：冲突域是指网段上的一台设备发送分组时，改物理网段上其他所有设备都需要侦探它。集线器连接的各设备就是一个典型冲突域。广播域是指，网络的一组设备侦听在该网段上发送的所有广播。 网桥和交换机(Switch)：都属于数据链路层，基于mac地址进行数据转发，网桥和交换机的每个物理端口属于一个冲突域，所有端口处于一个广播域，二者均能隔离冲突域但不能隔离广播域。区别：网桥主要由软件实现，交换机主要由硬件实现网桥只有少数几个端口；交换机可以有上百个；由于交换机才有硬件ASIC芯片进行线速转发交换，网桥速度慢于交换机。网桥使用存储转发机制，等收到了全部数据才转发；交换机除了存储机制外还有直接转发机制，只需要帧头到达处理后就可以转发，也是交换机处理快于网桥的原因之一。简单的说网桥就是个硬件网络协议翻译器，假设你有2台电脑，一台兼容机安装windows，一台是Apple安装OS2，那么两台电脑之间是默认网络协议是不同的 路由器位于网络层，扮演三层交换机角色，可隔离冲突和广播域，每个子网就属于一个广播域，不同子网间不能发送广播，要对广播进行控制就要使用路由器（或具有路由功能的三层交换机）。可以以路由器上的LAN口为单位分割广播域。路由器的基本功能是，把数据（IP 报文）传送到正确的网络，细分则包括：1、IP 数据报的转发，包括数据报的寻径和传送；2、子网隔离，抑制广播风暴；3、维护路由表，并与其它路由器交换路由信息，这是 IP 报文转发的基础；4、IP 数据报的差错处理及简单的拥塞控制；5、实现对 IP 数据报的过滤和记帐。 最后提一下网关，网关是一个很宽泛的概念，OSI各层几乎都有网关，但是通常是指路由器。 网关（协议转换器）是互连网络中操作在OSI网络层之上的具有协议转换功能设施，所以称为设施，是因为网关不一定是一台设备，有可能在一台主机中实现网关功能。 网关用于以下几种场合的异构网络互连： 1).异构型局域网，如互联专用交换网PBX与遵循IEEE802标准的局域网。 2).局域网与广域网的互联。 3).广域网与广域网的互联。 4).局域网与主机的互联（当主机的操作系统与网络操作系统不兼容时，可以通过网关连接）。 网关的分类 1)协议网关：协议网关通常在使用不同协议的网络区域间做协议转换。 2)应用网关：应用网关是在使用不同数据格式间翻译数据的系统。 3)安全网关：安全网关是各种技术的融合，具有重要且独特的保护作用，其范围从协议级过滤到十分复杂的应用级过滤 参考：http://network.51cto.com/art/201406/443304_all.htmhttp://www.cnblogs.com/imapla/archive/2013/03/12/2955931.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[桥接与二层转发的概念]]></title>
      <url>%2F2017%2F03%2F13%2F%E6%A1%A5%E6%8E%A5%E4%B8%8E%E4%BA%8C%E5%B1%82%E8%BD%AC%E5%8F%91%E7%9A%84%E6%A6%82%E5%BF%B5%2F</url>
      <content type="text"><![CDATA[桥接和二层转发的概念 二层转发：&ensp;&ensp;在链路层中，根据报文的目的MAC地址来对报文进行转发，由于数据链路层位于osi模型中的第二层，所以就称为二层转发。在二层转发中，不用对报文的头部做任何修改，但是在三层转发则是根据报文的IP地址来进行转发，同时要对报文的二层头部进行修改。&ensp;&ensp;实现机制：学习线程和报文转发线程，二层转发只和mac地址有关，和IP无关。 桥接的概念:&ensp;&ensp;把两台处于同一网段的设备通过网桥(实质就是交换机)连接在一起，网桥是一个二层转发的设备，通俗地说就是根据目的MAC地址把一台设备上的报文原封不动转发到对应的另外一台设备，网桥在整个转发过程中是透明的。 FDB表:信息转发表的缩写，每个网桥内都会维护一张信息转发表，会定时清理这些表中数据，称为FDB表项的老化，内容包含以下信息： MAC：设备mac地址 port：设备连接在交换机哪个接口网桥在收到报文后根据目的MAC查到的表项就知道报文的出端口，直接转发出去。利用mac地址学习，网桥设备每接收到一个报文就会根据报文的mac地址以及报文接收端口更新FDB表 路由桥接和中继有什么区别：中继：可以让一个主机路由连接多个从机路由，多路转发。需要更大内存桥接：只能一个路由连接另外一个路由，单对单通信 二层广播(帧广播)和三层广播(路由广播)的区别：举例：三层交换机下游两个网段，对应设备为a和b，a要和b通信，过程如下：1.首先根据网卡的ip地址和子网掩码计算出两个设备是否在一个网段，如果是就直接二层转发了，如果不是就跨网段转发2.如果是跨网段，要将数据包发送到网关进行三层转发3.a设备到网关的通信是二层转发，需要知道对方b的mac，所以a先读取电脑的arp缓存，看看网关ip和mac地址的关系，如果有关系就直接转发，如果没有就是用arp协议，将携带自己的ip地址和mac地址，目的地址为网关ip，mac地址为ffff-ffff-ffff的包发送给网关。网关接收到arp广播后，回复自己的mac，数据包为源网关ip和mac，目的地址为a的ip和mac。4.a接收到数据包后将ip和mac写入arp缓存表，并直接封装数据包，三层ip头为a的ip，目的ip为b的ip，二层帧格式为a的mac，目的为网关mac5.网关接收到a发来数据，拆包后根据目的ip进行寻址(路由表)，找到对应路径。三层交换机根据目的ip地址对本机的arp缓存表进行查找，找到ip和mac的对应关系就直接封装转发，如果没有就发送arp广播包获取目的ip的mac（只在b网段转发），b接收到之后就响应，发送自己的mac给三层交换机，和b同网段其他设备接收的话就丢弃。三层交换机知道b的包后转发包返回给b，三层数据包头为a的ip，目的ip是b的，二层数据帧包头是b网段的网关mac，目的mac为b的mac。b收到三层交换的数据包，拆包后获取数据，按照前面类似的过程通过三层交换机转发回a。 前面提到的网关就是路由或者带路由功能的交换机 参考：http://blog.csdn.net/duhf_think/article/details/41483153http://bbs.51cto.com/thread-888177-1.htmlhttp://iomem.com/index.php?archives/4-Ethernet-Bridges-under-Linux.html&amp;serendipity%5Bentrypage%5D=3&amp;serendipity%5Bentrypage%5D=all&amp;serendipity%5Bentrypage%5D=all]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[c中的预处理]]></title>
      <url>%2F2017%2F03%2F13%2Fc%E4%B8%AD%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86%2F</url>
      <content type="text"><![CDATA[c中的预处理 #define的作用：可以用来简化操作，交由预处理器处理速度一般要快于函数得到一个字的高位和低位字节 12#define WORD_LOW(xxx) ((byte) ((word)(xxx) &amp; 255))#define WORD_HIGH(xxx) ((byte) ((word)(xxx) &gt;&gt; 8)) 值得一提的是C语言下struct+typedef+函数指针可以做到面向对象的继承，重载和多态 &ensp;#define&ensp;归预处理器管理，typedef归编译器管理。举个例子来阐述它们之间的不同： 12345#define func void (*)(char)typedef void (*function)(int); //定义一个函数指针，参数类型为char，返回值是voidvoid a(function f); //truevoid b(func f); //error 取消之前的&ensp;#define&ensp;定义：&ensp;#undef&ensp; #ifndef的作用：防止头文件中相互嵌套重复定义，比如，定义了a.h文件和b.h头文件，其中在b.h中引入了a.h，然后在一个源文件d.c中同时引入了a.h和b.h，那么a.h就重复定义；了。这时候要引入#ifndef格式：&ensp; 1234#ifndef _XXX_H#define _XXX_H...#endif #ifdef的作用：&ensp;#ifdef&ensp;一般形式：12345#ifdef macro_name 代码段 1#else 代码段 2#endif 首先：12#ifdef identifier本质上等价于#if defined( identifier).#ifndef identifier本质上等价于#if !defined( identifier). 加入在前面定义了#define macro_name那么就会执行代码段1，否则执行2.注意无论&ensp;#define&ensp;后面的是什么(比如&ensp;#define macro_name后面无论加什么)，只要有&ensp;#define条件编译&ensp;就会执行&ensp;#ifdef&ensp;里面的代码在嵌入式中的应用：针对一些可以移植到不同平台设备的代码，你会看到类似： 12345#ifdef _ARM_#define func() armbar()#else //such as X86#define func() x86bar()#endif 另外附上一个参考： 123456789101112131415161718192021222324#define ABCD 2#include &lt;stdio.h&gt; int main(void)&#123; #ifdef ABCD printf(&quot;1: yes\n&quot;);#else printf(&quot;1: no\n&quot;);#endif #ifndef ABCD printf(&quot;2: no1\n&quot;);#elif ABCD == 2 printf(&quot;2: yes\n&quot;);#else printf(&quot;2: no2\n&quot;);#endif #if !defined(DCBA) &amp;&amp; (ABCD &lt; 2*4-3) printf(&quot;3: yes\n&quot;);#endif&#125; 输出： 1231: yes2: yes3: yes #if的作用：它和前面提到的&ensp;#ifdef&ensp;的主要区别就是：&ensp;#ifdef&ensp;是检查条件编译的，只要它前面有&ensp;#define&ensp;就会执行条件内的内容； #if是当宏定义为1时才执行(当然你也可以让宏定义等于特定值执行，比如#if macro==3)，类似于if可以简化前面提到的&ensp;#ifdef&ensp;的操作，怎么简化呢，比如你需要设置两个宏的判断： 123456#ifndef macro1#ifndef macro2 代码#endif#endif//当两个宏都满足才执行代码 简化: 12#if define(macro1)&amp;&amp;define(macro2)#endif 但是简化的方法不一定适用于旧版本编译器(C99支持)，如果要兼容旧版本编译器还是用前面比较繁琐的方法。 #error：&ensp;#error&ensp;宏用于在编译时提示一个错误并且会停止编译比如像前面的例子，我们在使用&ensp;#ifdef&ensp;检测宏是否定义的时候，可以在后面加&ensp;#error(“have not define\n”)&ensp;作为错误提示 #和##操作符：demo：针对#举个例子：1#define PRINT_INT(n) printf(#n &quot; = %d\n&quot;,n) 当我们调用&ensp;PRINT_INT(i+j);&ensp;，就会变成&ensp;printf(“i+j””=%d\n”,i+j);&ensp;，等价于&ensp;printf(“i+j=%d\n”,i+j);&ensp; 对于&ensp;##&ensp;： 12345#define xname(n) x ## n &lt;==&gt;//xname(2) 就展开成x4再比如：int xname(2)=10;//就展开为int x2=10； demo： 12345678910111213141516171819#include &lt;stdio.h&gt; //制造函数工厂并使用之#define FUNCTION(name, a) int fun_##name(int x) &#123; return (a)*x;&#125; FUNCTION(quadruple, 4)FUNCTION(double, 2) #undef FUNCTION#define FUNCTION 34#define OUTPUT(a) puts( #a ) int main(void)&#123; printf(&quot;quadruple(13): %d\n&quot;, fun_quadruple(13) ); printf(&quot;double(21): %d\n&quot;, fun_double(21) ); printf(&quot;%d\n&quot;, FUNCTION); OUTPUT(million); //注意缺少引号&#125; 输出： 1234quadruple(13): 52double(21): 4234million 参考：http://zh.cppreference.com/w/c/preprocessorhttp://blog.sina.com.cn/s/blog_4b4b54da0100r2l6.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mooc_python爬虫学习]]></title>
      <url>%2F2017%2F03%2F10%2FMooc-python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[Mooc_python爬虫学习&ensp;&ensp;在中国大学mooc上的python爬虫教程爬虫设计规模介绍：对于小型爬虫，只是少量扒取网页上的资源，使用request库就能够解决；对于中型爬虫，要引入scrapy库来解决对于大型爬虫，比如谷歌、百度的搜索引擎，就需要公司自身定制&ensp;&ensp;python爬虫过度扒取网站上的资源会对网站造成不小的压力，所以有些网站会对爬虫进行限制。限制的方式：1.通过识别自身允许访问的uer-agent来限制爬虫的行为(但是稍微高级的爬虫可以伪造uer-agent)2.通过robots协议来警告用户什么资源不能扒取 爬虫初实践： 扒取京东商品信息：123456789import requestssurl=&quot;...&quot;try: r=requests.get(url) r.raise_for_status()//错误就退出 r.encoding=r.apparent_encoding print r.text[0:1000]except: print &quot;something wrong&quot; 扒取亚马逊商品信息：假如我们使用前面京东爬虫的方式扒取亚马逊的商品信息，就会报503错误：123&gt;import requests&gt;r=requests.get(&quot;...&quot;)&gt;r.status_code() //提示503 下面来分析一下问题：123456789101112&gt;r.encoding&apos;ISO-8859-1&apos;&gt;r.encoding=r.apparent_encoding&gt;r.text //会提示api错误&gt;r.requests.headers //显示python的来源，亚马逊不运行访问&gt;k=&#123;&apos;user-agent&apos;:&apos;MOzilla/5.0&apos;&#125;//伪造头&gt;url=&quot;...&quot;&gt;r.requests.get(url,headers=k)&gt;r.status_code200&gt;r.requests.headers //显示Mozilla头&gt;r.text[:500] //获取 图片扒取：12345678910111213141516171819202122&gt;&gt;&gt; import os&gt;&gt;&gt;import requests url=&quot;http://imgsize.ph.126.net/?enlarge=true&amp;imgurl=http://edu-image.nosdn.127.net/9AD94813F74DFDE716B49C10A481CEE3.jpg?imageView&amp;amp;thumbnail=426y240&amp;amp;quality=100_230x130x1x95.png&quot;&gt;&gt;&gt; root=&quot;/home/simon/vscode/sublime/py/spider//&quot;&gt;&gt;&gt; path=root+url.split(&apos;/&apos;)[-1]&gt;&gt;&gt; try:... if not os.path.exists(root):... os.mkdir(root)... if not os.path.exists(path):... r=requests.get(url)... with open(path,&apos;wb&apos;) as f:... f.write(r.content)... f.close()... print &apos;save successfully&apos;... else:... print &apos;file already exists&apos;... except:... print &apos;failed&apos;... ... save successfully 最后指定的目录下保存了名为9AD94813F74DFDE716B49C10A481CEE3.jpg?imageView&amp;thumbnail=426y240&amp;quality=100_230x130x1x95.png的图片 BeautifulSoup的使用bs4这个库可以解析html和xml，帮助我们解析链接的资源（只要是带标签的资源都能解析），假如不引入，单纯打印text文本内容的时候，会显示很多杂乱无章的信息，加入bs4可以解决123456&gt;from bs4 import BeautifulSoup&gt;url=&quot;...&quot;&gt;r=requests.get(url)&gt;demo=r.text //假如直接打印demo会显示和乱的内容&gt;soup=BeautifulSoup(demo,&quot;html.parser&quot;)&gt;print soup.prettify() BeautifulSoup基本元素bs4有4个解析器，前面提到的html解析器是其中一种基本元素：tag标签：最基本的信息组织单元，分别用&lt;&gt;和&lt;/&gt;表面开头和结尾name标签：标签名字，&lt;p&gt;名字就是pattributes：标签属性，字典形式组织navigablestring：标签内非属性字符串comment：标签内字符串注释部分12345678910111213141516171819还是前面的例子&gt;&gt;&gt; soup.title&lt;title&gt;Python\u7f51\u7edc\u722c\u866b\u4e0e\u4fe1\u606f\u63d0\u53d6_\u4e2d\u56fd\u5927\u5b66MOOC(\u6155\u8bfe)&lt;/title&gt;&gt;&gt;&gt; tag=soup.a&gt;&gt;&gt; print tag&lt;a class=&quot;navLeft-func-f_div203_div204_a205&quot; href=&quot;http://www.icourse163.org&quot; target=&quot;_top&quot;&gt;&lt;img alt=&quot;&quot; class=&quot;navLeft-func-f_div203_div204_a205_img206&quot; height=&quot;28&quot; src=&quot;http://edu-image.nosdn.127.net/C0124E0336721FF65563B76A16A8143F.png?imageView&amp;amp;thumbnail=190y28&amp;amp;quality=100&quot; width=&quot;190&quot;/&gt;&lt;/a&gt;&gt;&gt;&gt; tag.attrs&#123;u&apos;href&apos;: u&apos;http://www.icourse163.org&apos;, u&apos;target&apos;: u&apos;_top&apos;, u&apos;class&apos;: [u&apos;navLeft-func-f_div203_div204_a205&apos;]&#125;&gt;&gt;&gt; tag.attrs[&apos;class&apos;][u&apos;navLeft-func-f_div203_div204_a205&apos;]&gt;&gt;&gt; tag.attrs[&apos;href&apos;]u&apos;http://www.icourse163.org&apos;&gt;&gt;&gt; print soup.p.string扫码下载APP 通过bs4解析器获取网页上的所有链接1234567url=&quot;...&quot;from bs4 import BeautifulSoupr.requests.get(url)demo=r.textsoup=BeautifulSoup(demo,&quot;html.parser&quot;)for link in soup.find_all(&apos;a&apos;): print link.get(&apos;href&apos;) bs4中的find_all方法：.find_all(name,attrs,recursive,string,**kwargs)返回一个列表类型，存储查找结果name：对标签名称的检索字符串attrs：对标签属性值的检索字符串recursive：是否对子孙全部检索，默认是Truestring：&lt;&gt;…&lt;/&gt;中字符串区域的检索字符串]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[c语言存储空间]]></title>
      <url>%2F2017%2F03%2F10%2Fc%E8%AF%AD%E8%A8%80%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%2F</url>
      <content type="text"><![CDATA[c语言存储空间 内存分布栈区(stack):分配和释放方式：有编译器自动分配和释放存放的内容：局部变量，参数特点：后进先出，可以用于现场保护堆区(heap):分配和释放方式：用户手动分配和释放，程序退出会自动释放存放的内容：动态分配内存的内容特点：可以自由划分大小，可以动态调整内存大小堆内存申请：系统有记录空闲内存地址的链表，用户申请内存的时候就会找到空间大于用户申请内存大小的节点，所以分配的地址是随机的剩余内存的处理多余部分经系统重新回收放到空闲内存链表首地址记录大小分配内存的首地址存放该堆的大小全局区/静态区:分配和释放方式：编译器分配内存，程序退出时系统自动释放内存存放的内容：全局变量，静态变量特点：全局和静态变量都是存储在同个区，初始化的两种变量和未初始化的变量存储在不同的两个区域，但是这两个区间相邻常量区:分配和释放方式：退出程序时系统自动释放存放内容：常量代码区:分配和释放方式：编译器分配，程序退出时系统自动释放存放内容二进制代码和特殊变量内存存放法顺序（高到低）：栈=&gt;堆=&gt;全局区=&gt;常量区=&gt;代码区 变量类型 register变量:使用场景:如果一个变量使用的频率很高，可以用register修饰，提高访问速度–修饰限制：只有局部变量和参数可以被声明为register变量，全局变量和静态变量不可以–数量限制：register修饰的变量直接存放在cpu寄存器中，资源宝贵，不可以定义太多 extern变量:&ensp;&ensp;同以外部变量只能被定义一次，声明为外部变量（就是在函数外部定义的变量），在本函数中使用。一般可以省略掉extern–作用域：&ensp;&ensp;单文件：在本文件开头声明extern A，后面某行中定义int A=1；A的作用域就是本文件从开头一直到结尾。多文件：在任意文件定义int A1；在本文件声明extern A，那么从当前位置到文件末尾都可以使用。–存放位置：存放在全局区 static变量:&ensp;&ensp;&ensp;&ensp;静态变量，修饰符是static。（静态变量属于静态存储方式，但是属于静态存储方式的变量不一定是静态变量，比如外部变量倏然属于静态存储方式，但是不一定是静态变量，要加上static就是才能成为静态全局变量）。&ensp;&ensp;&ensp;&ensp;局部变量经过static修饰之后就变成静态局部变量，它的生存期为整个源文件，但是作用域还是局限于本函数，只能在该函数使用，一旦退出函数，尽管变量还在，但是不能使用。&ensp;&ensp;&ensp;&ensp;全局变量用static就是静态全局变量，原本全局变量的作用域是多个源文件，但是static修饰之后该变量值在该源文件内有效，其他源文件不能使用。 总结： 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期；把全局变量改变为静态变量 后是改变了它的作用域， 限制了它的使用范围&ensp;&ensp;&ensp;&ensp;当static修饰函数时，函数的作用域就限制在了本文件中 参考：http://blog.csdn.net/shulianghan/article/details/20472269]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[c和指针]]></title>
      <url>%2F2017%2F03%2F09%2Fc%E5%92%8C%E6%8C%87%E9%92%88%2F</url>
      <content type="text"><![CDATA[C和指针&ensp;&ensp;大一学了c语言，但是发现实际上自己对c语言的掌握程度还是不足，特别是指针部分，所以再来复习一下。&ensp;&ensp;首先指明，指针的实质是地址，如果一个变量存储了一份数据的指针，我们就称它为指针变量。在c语言中可以用一个变量来存放指针，这个变量就是指针变量，指针变量的值就是某个数据的地址。&ensp;&ensp;假设我们有一个int型变量a，它存储的是整型数字1，并且占用0x10b的地址，另外还有一个指针变量p，它的值是0x10b，这样我们就可以说p指向了a，或者p是指向变量a的指针 定义指针变量1type *name; type *name=val; 表示这是一个指针变量，我们可以用去获取地址上的数据，type表示该指针变量指向的数据的类型。再举一个例子：1234int a=10;int *t;int *p=&amp;a;t=&amp;a;(*t=&amp;a也是一样效果，加上*显多余，因为前面已经声明了是一个指针) 此时，p指向a，注意p是一个指针变量，它的值应该是一个数据的地址，我们需要将变量a的地址赋予它又比如：12345678int **p;int *a=10;*p=a;int b=9;int c=8;int *pp;*p=&amp;b;p=&amp;c; 上面我们定义了一个二级指针，二级指针最终的指向是10，我们需要将10对应的地址（也就是a这个指针变量）赋予指针变量*p。 我们可以简单地总结一下指针的创建和赋值：定义指针的时候必须带有,让指针变量指向对应值的时候等号后面应该是一个地址。当已经定义了一个指针变量后，后面的赋值不用也可以。1234int x, y, *px = &amp;x, *py = &amp;y;y = *px + 5; //表示把x的内容加5并赋给y，*px+5相当于(*px)+5y = ++*px; //px的内容加上1之后赋给y，++*px相当于++(*px)y = *px++; //相当于y=(*px)++ 明确概念参考：&ensp;&ensp;这里分析一下静态内存，栈内存和动态分配的内存(也就是堆内存)的区别：&ensp;&ensp;(1) 从静态存储区域分配。在程序编译的时候内存就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。&ensp;&ensp;(2) 在栈上创建。在执行函数的时侯(无论何时到达一个特殊的执行点(左花括号)时，存储单元都可以在栈上被创建。出了执行点(右花括号)，这个存储单元自动被释放)，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。&ensp;&ensp;(3) 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。字符数组和字符指针的区别：12char p[]=&quot;abc&quot;; //相当于局部变量，在堆内存存放char *p=&quot;abc&quot;; //相当于常量，在静态内存存放 指针用在参数传递&ensp;&ensp;当我们在a函数定义了一对实参，然后在a函数中调用b函数（b函数中的形参来源是a函数的一对实参，并且b函数要对传入的数据进行互换），如果我们只是使用简单的变量，那么最终在a函数中不能得到互换的数据。这是因为在a函数定义局部变量的时候，实参本身会生成一份副本传入到b函数中，但是b函数在引入形参的时候实际上引用的是a函数实参的副本，在b函数中对副本进行运算之后，修改的只是副本的数据，并没有影响到实参。所以，要达到互换的目的，我们需要在函数当中引入指针的概念。 指针参数如何传递内存?http://www.cnblogs.com/kaituorensheng/p/3246900.html &ensp;&ensp;如果函数的参数是一个指针，不要指望用该指针去申请动态内存。比如下面：12345678910void GetMemory(char *p, int num)&#123; p = (char *)malloc(sizeof(char) * num);&#125;void Test(void)&#123; char *str = NULL; GetMemory(str, 100); // str 仍然为 NULL strcpy(str, &quot;hello&quot;); // 运行错误&#125; &ensp;&ensp;Test函数的语句GetMemory(str,200)并没有使得str获得期望的内存，str依然是NULL，why？问题就在GetMemory函数上。编译器总是要为每个参数制作临时副本，指针参数p的副本设做_p，编译器是_p=p，如果函数体内（就是动态分配内存）的程序修改了_p的内容，就会导致参数p的内容作相应的修改，这就是指针可以作为输出参数的原因。在这里，_p申请了新内存，只是把_p所指向的内存地址改变了，但是p还是没有改动，所以GetMemory不能输出任何东西，而且这样很容易造成内存泄漏。开始的时候和_p都是指向同一块内存，当修改地址1的内容时，实际上也就是修改了p所指向的内存的内容，这和我们平常使用指针参数的情况是一样的。然而当我们修改_p的值时（为它分配动态内存），只是将_p指向另外一地址（地址2），而p还是指向地址1，相当于值传递，无法改变变量内容。如果要用指针传递内存，我们要引用二级指针123456789101112void GetMemory2(char **p, int num)&#123; *p = (char *)malloc(sizeof(char) * num);&#125;void Test2(void)&#123; char *str = NULL; GetMemory2(&amp;str, 100); // 注意参数是 &amp;str，而不是str strcpy(str, &quot;hello&quot;); cout&lt;&lt; str &lt;&lt; endl; free(str); &#125; sizeof和指针举例：12345char str[]=&quot;abcd&quot;，sizeof(str)==5,str类型是char[5];sizeof(&quot;abcd&quot;)==5，因为&quot;abcd&quot;的类型是const char[5]；char str[10]=&quot;abcd&quot;，sizeof(str)==10，此时str类型是char[10];void func(char a[10],int b[20],char *p)，sizeof(a)==sizeof(b)==sizeof(p)==4，因为a的类型是char*,b的类型是int*,p的类型是char*。 另外我们提一下出现频率很高的const指针首先先明确，const限定符修饰的变量只能被读123456const int a=2;int b=3;a=b; //非法b=a; //合法extern const i; //合法extern const int j=2;//非法，不能再次赋值 但是，我们还是有途径修改const定义的常量的值：123const int i=0;int *p=(int*)&amp;i;i=10; //通过强制类型转换，把地址赋给变量，再次修改就可以改变const常量值 const char p/char const p：这个时候const用来修饰指针所指向的变量，即指针指向的内容为常量，不能修改其内容，但是可以修改其指向（地址）。当用户想要传入一个指针参数给一个外部函数时，又不想外部函数对这个参数的修改会影响到本身作用域里原先的值，而且又要让外部函数能够对这个传入的参数进行修改用在自身，那么就要引入这个概念，实际上，我们的strcpy函数原型中有一个参数就是这种格式1234567const char *t=0;*t=1; //非法t++; //合法char *p;const char *pp=p; //正确char **pa;const char **pt=pa; //错误，无法从char **转换为const char ** char *const p:这时候const修饰指针本身，指针是常量，不能修改其指向，但是可以修改其内容。123char* const p=0;*p=1; //合法p++; //非法 如果要设置指向和内容都不能改写，类似这样char const * const a; 123456789//const char ** 的赋值过程 const char c1=&apos;x&apos;; const char * p0=&amp;c1; const char ** p1=&amp;p0; // char ** 的赋值过程 char c2=&apos;y&apos;; char * p2=&amp;c2; char ** p3=&amp;p2; char * const * p4=p3;// 注意：char * const * 就是char ** 的赋值兼容类型 形参中引用指针和引用数组&ensp;&ensp;实际上，在形参中定义数组和定义指针的效果是一样的，数组作为参数传递的时候会被弱化为指针，传递进去的是数组的首元素地址 void *void是通用指针类型，即指向void的指针，可以指向任意类型的地址。如果函数的参数和返回值可以是任意类型，就可以用void作为参数或返回值。 注意：void和其他类型不能相互复制，比如int变量可以复制给void变量，但是void变量要赋值给int变量就要强制转换为int类型。void类型不能进行加减乘除运算。GNU中void等价与char* 12345char s[3][10],(*k)[3],*p;p=s;p=k;p=s[0]; //正确k=s; 123456789#include&lt;stdio.h&gt;struct ord &#123;int x,y;&#125; dt[2]=&#123;1,2,3,4&#125;;main()&#123;struct ord *p=dt;printf(&quot;%d,&quot;,++p-&gt;x);printf(&quot;%d,&quot;,++p-&gt;y);&#125; 定义了一个结构体，里面有两个整型变量，dt是一个数组，里面有两个元素，每个元素都是一个结构体，并且对两个元素都进行初始化，第一个元素作为一个结构体里面的两个整数值为x=1，y=2，第二个为x=3，y=4]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[了解hexo主题的布局]]></title>
      <url>%2F2017%2F03%2F09%2F%E4%BA%86%E8%A7%A3hexo%E4%B8%BB%E9%A2%98%E7%9A%84%E5%B8%83%E5%B1%80%2F</url>
      <content type="text"><![CDATA[了解hexo主题的布局很棒的一本小书：https://pengloo53.gitbooks.io/hexo/content/&ensp;&ensp;&ensp;hexo的主题在theme目录下，以本人使用的yilia主题来说，它的一个基本内容是这样的： 1234567891011121314yilia/├── _config.yml├── languages/├── source/└── layout/ ├── _partial/ ├── _widget/ ├── archive.ejs ├── category.ejs ├── index.ejs ├── layout.ejs ├── page.ejs ├── post.ejs └── tag.ejs 文件夹的解释： language语言文件夹 layout布局文件夹，hexo默认使用swig模板引擎，用户可以安装插件来获取EJS、Haml或Jade支持，hexo根据模板文件的扩展名来决定所使用的模板引擎，比如 12layout.ejs --使用EJSlayout.swig --使用swig source资源文件夹，除了模板之外的文件，比如css、js都应该放在这里。如果文件或文件夹的名称以_开头或.隐藏文件就会被忽略。如果文件可以被渲染，会经过解析然后存到public目录，否则直接拷贝到public _partial局部模板目录，局部模板的设计可以让你在不同模板之间进行分享，比如你的header、footer等等 12partial/header.ejs&lt;h1 id=&quot;logo&quot;&gt;&lt;%= config.title %&gt;&lt;/h1&gt; 123index.ejs&lt;%- partial(&apos;_partial/header.ejs&apos;,&#123;config.title:&apos;Hello&apos;&#125;) %&gt;&lt;div id=&quot;content&quot;&gt;Home page&lt;/div&gt; 最后生成：12&lt;h1 id=&quot;logo&quot;&gt;Hello&lt;/h1&gt;&lt;div id=&quot;content&quot;&gt;Home page&lt;/div&gt; 前面的配置还引入了局部变量的概念,局部变量就是config.title 默认布局layout.ejs是hexo的默认布局模板文件，里面的内容：1234567891011121314151617181920&lt;%- partial(&apos;_partial/head&apos;) %&gt;&lt;body&gt; &lt;div id=&quot;container&quot;&gt; &lt;div class=&quot;left-col&quot;&gt; &lt;%- partial(&apos;_partial/left-col&apos;, null, &#123;cache: !config.relative_link&#125;) %&gt; &lt;/div&gt; &lt;div class=&quot;mid-col&quot;&gt; &lt;%- partial(&apos;_partial/mobile-nav&apos;, null, &#123;cache: !config.relative_link&#125;) %&gt; &lt;!--是否开启最近通知--&gt; &lt;% if(theme.recent)&#123;%&gt; &lt;%- partial(&apos;_partial/recent&apos;,null,&#123;cache: !config.relative_link&#125;) %&gt; &lt;% &#125; %&gt; &lt;div class=&quot;body-wrap&quot;&gt;&lt;%- body %&gt;&lt;/div&gt; &lt;!--&lt;%- partial(&apos;_partial/footer&apos;) %&gt;--&gt; &lt;/div&gt; &lt;%- partial(&apos;_partial/after-footer&apos;) %&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&ensp;&ensp;可以看到文件里面包含了许多其他模板，其中很多是来自_partial目录下的，这说明了layout.ejs就是一个完整的页面。&ensp;&ensp;每个hexo站点基本可以分为index(首页)、post（文章详细页）、page（导航标签页）、archive（归档页）、category（类别页）还有tag（标签页），它们都可以在layout.ejs找到对应文件。它们的每一个都是一种布局，用以替换掉前面layout.ejs文件中的&lt;%- body%&gt;。随便打开其中的一些文件，比如category.ejs和archive.ejs：12345category:&lt;%- partial(&apos;_partial/archive&apos;, &#123;pagination: config.category, index: true&#125;) %&gt;archive:&lt;%- partial(&apos;_partial/archive&apos;, &#123;pagination: config.category, index: true&#125;) %&gt;对比起来没有任何区别，都使用_partial/archive局部模块。首页布局 参考：hexo官方文档Create an Hexo Theme - Part 1: Index]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Text开发环境搭建]]></title>
      <url>%2F2017%2F03%2F08%2FSublime%20Text%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[Sublime Text开发环境搭建&nbsp;&nbsp;&emsp;Sublime text是一个很强的跨平台编辑器，如果你只认为它和普通编辑器一样那就误解了，实际上，它有很多丰富的插件，我们可以通过拓展插件的方法来搭建一个非常完备的开发环境。甚至，很多时候，它可以替代IDE的很多工作（好多IDE真的是内存杀手，尽管它们有很多功能）。官网：http://www.sublimetext.com/&nbsp;&nbsp;&emsp;安装插件之前，我们要先安装package control包管理器：依次点开view-&gt;show control(快捷键 Ctrl+`),在控制台下输入: 1import urllib.request,os,hashlib; h = &apos;df21e130d211cfc94d9b0905775a7c0f&apos; + &apos;1e3d39e33b79698005270310898eea76&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) 可以参考：https://packagecontrol.io/installation安装完插件管理之后，通过菜单 Preferences&gt; Package Control （快捷键 Ctrl+Shift+P） 来开启安装插件，在打开的输入框中输入install ，从提示的待选项中选择 Install Package。这里提一下，本人在ubuntu14.04上安装sublime text3插件的时候，当进行到install package那个步骤的时候，系统提示了错误 12345Package ControlThere are no packages available for installationPlease see https://packagecontrol.io/docs/troubleshooting for help 网络出现了问题。。。解决：1.在终端输入：dig @8.8.8.8 -t A sublime.wbond.net +noall +answer然后找到类似下面的结果： 1234; &lt;&lt;&gt;&gt; DiG 9.9.5-3-Ubuntu &lt;&lt;&gt;&gt; @8.8.8.8 -t A sublime.wbond.net +noall +answer; (1 server found);; global options: +cmdsublime.wbond.net. 82 IN A 50.116.34.243 2.后面的数字就是你需要改的host，在/etc/hosts下，填入： 50.116.34.243 sublime.wbond.net原文：http://stackoverflow.com/questions/25105139/sublime-text-2-there-are-no-packages-available-for-installation安装完毕之后可以根据Package Control Messages这个文件查看插件信息。当然你也可以删除插件，在前面提到的package control中输入remove package，选择要删除的插件 前端的插件 Tag:Html/xml代码格式化 CSScomb:CSS属性排序 JsFormat:JS代码格式化 Emmet：快速生成HTML代码段的插件 jQuery: 智能提示jQuery代码 HTML5:HTML5 bundle Js​Format: JS代码格式化 PHP的插件 sublimelinter + sublimelinter-php:PHP代码语法检测，在写的时候就可以知道是否符合PHP语法，及时修改 SublimeCodeIntel: PHP代码自动补全工具 Xdebug Client：调试插件，可以对PHP代码设置断点、单步、步入、步出、步进等调试，以及查看实时变量值 DocBlockr： 可以自动生成PHPDoc风格的注释 C/C++的插件 Python的插件 其他的插件 Alignment:代码对齐 Bracket​Highlighter:括号高亮 ConvertToUTF8:：支持Sublime打开 GBK, BIG5, EUC-KR, EUC-JP, Shift_JIS 等编码文件的插件 Bracket Highlighter：用于匹配括号，引号和html标签。对于很长的代码很有用 SideBar Enhancements:这个插件改进了侧边栏，增加了许多侧边栏的右键功能 Themr：主题管理，切换主题的时候，不用自己修改配置文件了，用这个可以方便的切换主题 SFTP: ftp插件 GBK to UTF8:GBK转换为UTF8 Clipboard History:剪切板历史记录 Git:整合git Sublimall:同步其他设备的ST AutoFileName:补全文件路径 参考牛人的经验：https://github.com/jikeytang/sublime-texthttp://www.awaimai.com/940.htmlhttps://segmentfault.com/a/1190000000382934http://blog.jobbole.com/79326/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HEXO主题定制]]></title>
      <url>%2F2017%2F03%2F08%2FHEXO%E4%B8%BB%E9%A2%98%E5%AE%9A%E5%88%B6%2F</url>
      <content type="text"><![CDATA[hexo主题定制 后续也会更新… 其实也就是在网上找的一些定制hexo主题的链接，废话不多说，直接放出来：通过这篇文章先大致了解Hexo的布局初步了解Hexo站点布局Landscape主题定制：hexo私人定制定制自己的hexo主题【实用技能】教你定制Hexo的landscape打造自己的主题Hexo主题-在博客左上角添加ForkMeOnGithub功能Yilia主题添加站内搜索功能-swiftype站内搜索(swiftpye)、百度统计、代码高亮 站内搜索-很全本地站内搜索-json解析(继承自前文,存在不足)站内搜索-针对前文进一步优化站内搜索-google平台博客插件-字数统计、网易云音乐、更新时间主题优化在Hexo中给文章加目录]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[分析openwrt内部交换机设置]]></title>
      <url>%2F2017%2F01%2F18%2F%E5%88%86%E6%9E%90openwrt%E5%86%85%E9%83%A8%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%AE%BE%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[分析openwrt内部交换机设置先放出一张openwrt内部的网络结构图：上述路由是MT7620芯片 eth0（LAN） eth1（WAN） 路由可分成两部分，一个是路由部分，另外一个是交换机部分。一个交换机可分成6个端口，其中5个是用户可视，如上面的Port0-4，不可视的是Port5，和路由器的eth0相连。所以，家用路由多数是5口。路由器上的wan和lan口其实都是一个交换机上的不同端口而已，用户可以通过VLAN技术来划分wan和lan的数目和位置，通过VLAN设置，可以对交换机进行端口隔离，抑制广播风暴。通过VLAN划分，可以使eth0区分不同端口的数据包，在路由上建立起虚拟接口eth0，eth0.1，通过控制两个虚拟接口]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Use_MarkDown]]></title>
      <url>%2F2017%2F01%2F17%2FUse-MarkDown%2F</url>
      <content type="text"><![CDATA[MarkDown常用技巧可参考:markdown中文网知乎：markdown是什么CSDN markdown专栏 MarkDown作者Aaron Swartz:![MarkDown作者] (“https://pic4.zhimg.com/606e14127233ca0a935032b19b5df3a7_b.jpg“) 纪念斯沃茨的网站(markdown编写) ###标题标题共有6级，用#表示，后面接内容，#越多代表级别越高，尺寸越小 ###加粗，斜体在需要加粗的文字两端加入`加粗文字`或者_加粗文字_如果要输出斜体效果，那么就是单个的*或者是单个的_而且，加粗和斜体标识最好都是放在&lt;font&gt;内 ###使排版更有层次比如你需要下面的结果1. 第一节 第二节(你不用敲 “2”，自动就有了） 第一小节（推荐每层次缩进四个空格） 小小节 1 小小节 2 第二小节 那么就像下面那样输入： 第一节 第二节(你不用敲 “2”，自动就有了）` 第一小节（推荐每层次缩进四个空格） 小小节 1 小小节 2 第二小节 换行后的*和前面持平的一行的一个元素效果相同，比如第一行的1.。第二行如果缩进与第一行持平，那么保持这种结构持续下去显示2.。假如要和前面的效果不同，那么就输入一个tab不和前面持平更好的方法： &lt;ol&gt;&lt;li&gt;有序列表第一项&lt;/li&gt;&lt;li&gt;有序列表第二项&lt;/li&gt;&lt;li&gt;有序列表第三项&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt; 输出效果：有序列表第一项有序列表第二项有序列表第三项又比如：&lt;li&gt;&lt;p&gt;这是一个列表项&lt;/p&gt;&lt;p&gt;这是第一列表项中的第二个段落&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;这是列表的另一个项&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt; 输出效果：这是一个列表项这是第一列表项中的第二个段落这是列表的另一个项目###居中:用&lt;center&gt;标签扩起来###换行：&emsp;方法1：连续两个以上空格+回车&emsp;方法2：使用html语言换行标签:&lt;br&gt; （假如要输出&lt;br&gt; 这样的文字，那么在左右用`` 扩起来）&lt;br&gt; 符号要在行首输入####首行缩进两个字符：(每个表示一个空格，连续使用两个)半方大的空白&amp;ensp;或&amp;#8194;全方大的空白&amp;emsp;或&amp;#8195;不断行的空白格&amp;nbsp;或&amp;#160; ###字体颜色、大小、字型 &lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt; &lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=7 face=&quot;黑体&quot;&gt;color=#0099ff size=72 face=&quot;黑体&quot;&lt;/font&gt;&lt;font color=#00ffff size=72&gt;color=#00ffff&lt;/font&gt;&lt;font color=gray size=72&gt;color=gray&lt;/font&gt; 也可以把颜色代号换成颜色名称 字体效果：我是黑体我是微软雅黑我是华文彩云 ###背景颜色：&lt;td&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=Chartreuse&gt;Chartreuse&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 也可以把颜色名称换成颜色代号 颜色效果： #F0F8FF #FAEBD7 #00FFFF #7FFFD4 #F0FFFF #F5F5DC #FFE4C4 #FFEBCD #0000FF #8A2BE2 #A52A2A AliceBlue AntiqueWhite Aqua Aquamarine Azure Beige Bisque BlanchedAlmond Blue BlueViolet Brown #DEB887 #5F9EA0 #7FFF00 #D2691E #FF7F50 #6495ED #FFF8DC #DC143C #00FFFF #00008B #008B8B BurlyWood CadetBlue Chartreuse Chocolate Coral CornflowerBlue Cornsilk Crimson Cyan DarkBlue DarkCyan 假如要在`` 扩起来的字符当中输入内嵌符号而且不要转义，还是要用`` 扩起来一般情况下，当`` 成对出现的时候，要在反引号两边在加一对反引号，并且外边的要和里面的保持一个空格 ###代码区块代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如普通段落：void main(){printf(“Hello, Markdown.”);} void main() { printf(&quot;Hello, Markdown.&quot;); } 也可以用**` 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;br&gt;或者也可以使用&lt;font size=4 face=&quot;黑体&quot; color=#8B008B&gt;**`&lt;pre&gt;&lt;code&gt;代码段&lt;/code&gt;&lt;/pre&gt;`**&lt;/font&gt;###分割线最常使用的分割线用3个或以上的`*`,还可以用`-`和`_`******###链接链接分作下列形式####1.行内式&lt;font size=4 face=&quot;黑体&quot; color=#8B008B&gt;**`[名称](链接)`**&lt;/font&gt;&lt;br&gt;比如：[百度](https://www.baidu.com)####2.参考式&lt;font size=4 face=&quot;黑体&quot; color=#8B008B&gt;**`[名称1][1]`**&lt;/font&gt;&lt;br&gt;&lt;font size=4 face=&quot;黑体&quot; color=#8B008B&gt;**`[名称2][2]`**&lt;/font&gt;&lt;br&gt;&lt;font size=4 face=&quot;黑体&quot; color=#8B008B&gt;**`[1]:链接1`**&lt;/font&gt;&lt;br&gt;&lt;font size=4 face=&quot;黑体&quot; color=#8B008B&gt;**`[2]:链接2`**&lt;/font&gt;&lt;br&gt;比如：[百度][1][1]:https://www.baidu.com####3.自动链接式&lt;font size=4 face=&quot;黑体&quot; color=#8B008B&gt;**`&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;`**&lt;/font&gt;&lt;br&gt;效果就是：&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;###图片&lt;font size=4 face=&quot;黑体&quot; color=#8B008B&gt;**`![Alt text](/path/to/img.jpg)`**&lt;/font&gt;&lt;font size=4 face=&quot;黑体&quot; color=#8B008B&gt;**`![Alt text](/path/to/img.jpg &quot;Optional title&quot;)`**&lt;/font&gt;一个感叹号!开头；其后紧跟一对中括号，中括号内存放图片的alt`属性；其后紧跟一对小括号，小括号内存放图片的URL或路径，及可选的用双引号或单引号或小括号括起来的图片title这里 &quot;id&quot; 是图片引用标识。图片引用定义的语法与链接定义完全相同：&lt;br&gt;####插入外链接图片：&lt;font size=4 face=&quot;黑体&quot; color=#8B008B&gt;**`![说明]:(url/to/image)`**&lt;/font&gt;###表格制作表格有两种方法:####1.html原生表格 时间 地点 人物 1.1 深圳 马化腾 1.2 北京 雷军 1234567891011121314151617181920212223&lt;br&gt;&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;span4&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;时间&lt;/td&gt; &lt;td&gt;地点&lt;/td&gt; &lt;td&gt;人物&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1.1&lt;/td&gt; &lt;td&gt;深圳&lt;/td&gt; &lt;td&gt;马化腾&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1.2&lt;/td&gt; &lt;td&gt;北京&lt;/td&gt; &lt;td&gt;雷军&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/div&gt;&lt;font size=4 face=&quot;黑体&quot; color=#8B008B&gt; … ```如果想占更多或更少的宽度，把span4修改为其他值，如span6（总宽度是span8，按比例算下就行） ####2.markdown原生表格或者像下面那样:`&lt;br&gt;|水果|价格|数量|&lt;br&gt;|:-|:-:|-:|&lt;br&gt;|香蕉|$1|5|&lt;br&gt;|苹果|$1|6|&lt;br&gt;|草莓|$1|7|`效果： 水果 价格 数量 香蕉 $1 5 苹果 $1 6 草莓 $1 7 又比如下面的效果： 函数名称 说明 ID help() 展示帮助窗口 delete() 删除文件 2 copy() 复制文件 3 实现方式:`&lt;br&gt;| 函数名称 | 说明 | ID|&lt;br&gt;| ——–| ——– ||&lt;br&gt;| help() | 展示帮助窗口 |&lt;br&gt;| delete() | 删除文件 |2|&lt;br&gt;| copy() | 复制文件 | 3|` 可以看出，实际上表格的输入不一定要是对称的，并且首行一定是加粗，作者也可以在表格内自定义表格内容的文字效果 另外，如果需要表头跟内容不一样，可以将&lt;td&gt;表头内容&lt;/td&gt;换成&lt;th&gt;表头内容&lt;/th&gt;。 如果表格内文需要换行，可以在要换行的内容后加入 &lt;br&gt;，后面的内容就会跑到下一行。 如果有跨行或者跨列的单元格，可用&lt;th colspan=&quot;跨列数&quot;&gt;内容&lt;/th&gt;。跨行则是用rowspan=”跨行数”。 如果要调整某一列的宽度，可使用：&lt;th width=&quot;宽度值或百分比&quot;&gt;表头内容&lt;/th&gt;。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo与github搭建个人博客]]></title>
      <url>%2F2017%2F01%2F17%2Fhexo%E4%B8%8Egithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[HEXO与Github.io搭建个人博客 ###HEXO搭建&nbsp;&nbsp;&nbsp;&nbsp;HEXO是基于Node.JS的一款简单快速的博客框架，能够支持多线程，支持markdown，可以将生成的静态网页发布到github.io以及coding上。要使用搭建HEXO博客，先安装hexo1.安装node.js sudo apt-get install -y python-software-properties software-properties-commonsudo add-apt-repository ppa:chris-lea/node.jssudo apt-get updatesudo apt-get install nodejs2.安装npm&nbsp;&nbsp;&nbsp;&nbsp;npm全名：Node Package Manager，是Nodejs的包管理器。ubuntu16.04LTS自带nodejs和npm，但是版本较低，假如要安装最新的，先移除自带的。 sudo apt-get remove nodejs &amp;&amp; sudo apt-get remove npm再清理依赖包： sudo apt-get autoremove官网上下载nodejs： cd /opt &amp;&amp; wget https://nodejs.org/dist/v4.4.5/node-v4.4.5-linux-x64.tar.xzxz -d node-v4.4.5-linux-x64.tar.xz &amp;&amp; tar vxf node-v4.4.5-linux-x64.tar让任意目录可以访问，先配置环境变量 sudo vim /etc/profile文件最后加上 export PATH=$PATH:/opt/node-v4.4.5-linux-x64/bin也可以通过软链接，使得任意目录可访问将node和npm链接到系统默认的PATH目录下的一个，软链接方式如下 ln -s /home/simon/node-v4.4.5-linux-x64/bin/node /usr/local/bin/nodeln -s /home/simon/node-v4.4.5-linux-x64/bin/npm /usr/local/bin/npm同步文件配置： source /etc/profile查看版本： node –version &amp;&amp; npm –version3.安装hexo国外站点网速较慢，建议换成淘宝站点 npm install -g npm –registry=https://registry.npm.taobao.orgnpm –version接下来安装hexo-cli切换到一个合适的目录下 npm install -g hexo-cli下载完毕之后可以检测一下：hexo –version4.配置hexo本地文件在安装插件的时候，最好都是用root身份执行，不然经常遇到一些问题初始化本地路径 cd /home/simon/hexo &amp;&amp; hexo init生成node_modules npm install生成本地博客 hexo ghexo server在浏览器下输入http://localhost:4000，成功的话就生成hexo的标准界面 ###部署到github&nbsp;&nbsp;&nbsp;&nbsp;新建一个repository，例如web（网上说要把名字设置成your_github_name.github.io这种格式，否则会404，但是我没有采用，也能生成）修改hexo根目录下的_config.yml，新增关联仓库deploy: type: git repository: https://github.com/simonid/web.git branch: master注意了，变量名之前要有两个空格，参数值前要有一个空格，通过:分割假如格式不对，不能被识别，比如：You should configure deployment settings in _config.yml first! Available deployer plugins: git 这样的错误或者：FATAL remote: Repository not found.完成之后，到github上完成部署在项目的setting项找到Github Pages，生成项目回到终端 hexo deploy如果报错说缺少deployer：npm install hexo-deployer-git –save打开 https://simonid.github.io/web/ 就可以看到效果，同时自己的github项目也会有文件更新注：中途可能遇到github的配置问题，请尝试用sshssh-keygen -C “username@email.com” -t rsa Note: “username@email.com”需要更换成你在Github上注册的Email地址或者是Username这样会在家目录生成一个公钥文件夹.ssh，其中id_rsa.pub是Github需要的SSH公钥文件。复制后粘贴到github上hexo简写命令格式： hexo g == hexo generate(生成静态网页)hexo d == hexo deploy（部署）hexo s == hexo server（测试）hexo n xxx （new article）hexo cleanhexo help&nbsp;&nbsp;&nbsp;&nbsp;还有其他选项：init 创建一个hexo项目migrate 从其他系统向hexo迁移version 查看hexo的版本–config参数，指定配置文件，代替默认的_config.yml–debug参数，调试模式，输出所有日志信息–safe参数，安全模式，禁用所有的插件和脚本–silent参数，无日志输出模式hexo有许多的主题和插件，可以通过npm、git工具来进行下载，放在theme下hexo根目录的目录及文件说明： scaffolds 脚手架，也就是一个工具模板 scripts 写文件的js，扩展hexo的功能 source 存放博客正文内容 source/_drafts 草稿箱 source/_posts 文件箱 themes 存放皮肤的目录 themes/landscape 默认的皮肤 _config.yml 全局的配置文件 db.json 静态常量 _posts目录：Hexo是一个静态博客框架，因此没有数据库。文章内容都是以文本文件方式进行存储的，直接存储在_posts的目录。Hexo天生集成了markdown，我们可以直接使用markdown语法格式写博客，例如:hello-world.md。新增加一篇文章，就在_posts目录，新建一个xxx.md的文件。 themes目录：是存放皮肤的，包括一套Javascript+CSS样式和基于EJS的模板设置。通过在themes目录下，新建一个子目录，就可以创建一套新的皮肤，当然我们也可以直接在landscape上面修改。 ###全局配置 _config.yml是全局的配置文件：很多的网站配置都在这个文件中定义。 站点信息: 定义标题，作者，语言 URL: URL访问路径 文件目录: 正文的存储目录 写博客配置：文章标题，文章类型，外部链接等 目录和标签：默认分类，分类图，标签图 归档设置：归档的类型 服务器设置：IP，访问端口，日志输出 时间和日期格式： 时间显示格式，日期显示格式 分页设置：每页显示数量 评论：外挂的Disqus评论系统 插件和皮肤：换皮肤，安装插件 Markdown语言：markdown的标准 CSS的stylus格式：是否允许压缩 部署配置：github发布 hexo搭建的时候遇到样式未加载的解决假如样式未加载成功，很大几率就是用户在设置项目名称的时候没有定义为github的id.io形式，如果不想把项目定义成这样，可以在根目录下的配置文件下的root加上你的自定义的项目名称另外指出，在使用oschina做pages服务的时候，我的域名有一段被固定为了osid，然后在deploy的时候账号名要输入osid才不会出错。。。 最详细的资料其他资料1其他资料2]]></content>
    </entry>

    
  
  
</search>
