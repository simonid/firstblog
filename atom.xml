<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://simonid.github.io/"/>
  <updated>2017-03-08T05:19:48.000Z</updated>
  <id>https://simonid.github.io/</id>
  
  <author>
    <name>simon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://simonid.github.io/2017/03/16/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1NetworkManager%E4%B8%8Einterfaces%E5%86%B2%E7%AA%81%E7%9A%84%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/"/>
    <id>https://simonid.github.io/2017/03/16/记录一次NetworkManager与interfaces冲突的解决过程/</id>
    <published>2017-03-16T05:47:42.001Z</published>
    <updated>2017-03-08T05:19:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;</p><h3>记录一次NetworkManager与interfaces冲突的解决</h3><br><br><br>&emsp;主机是ubuntu14.04，之前改过/etc/network/interfaces的配置内容（设置了静态ip），然后发现图形界面上的网络设置失效了，而且因为修改了interfaces之后还不能连接网络，ifconfig的时候不显示wlan0和eth0的信息，反而多了一个tun0-00。下面是一些解决的步骤：<p></p>
<p>&emsp;首先，重新编辑interfaces文件和/etc/resolv.conf文件，使他们恢复默认设置，然后重启，失败。先解决eth0的问题吧。网线接上电脑，手动开启eth0：</p>
<p>sudo ip link set eth0 up 或 sudo ifconfig eth0 up</p>
<p>&emsp;再查看一下，ifconfig，如果没有ipv4地址，尝试：<br></p>
<font color="#DC143C"><br>sudo dhclient eth0<br></font><br><br>&emsp;然后ping一下同网段ip，失败的话，尝试nc命令<br><br>&emsp;如果ICMP被禁了，使用nc命令或者telnet更适合，且可以探测端口是否开放,虽然DHCP端口是67，不过通常DHCP和DNS服务器是同一台机器，因此顺便测试53端口：<br><br>nc -zv 192.168.1.1 67<br><br>nc -zv 192.168.1.1 53<br><br><a id="more"></a><br>&emsp;如果服务器的IP不是通过DHCP获取的动态IP，而是静态IP，则需要手动设置IP地址，使用ifconfig配置:<br><br>sudo ifconfig eth0 192.168.1.105/24 gw 192.168.1.1<br><br>或者<br><br>sudo ip addr add 172.16.0.2/24 dev eth0<br><br>sudo route add default gw 172.16.0.1 dev eth0<br><br>配置完eth0之后，查看wlan0。<br><br>&emsp;ubuntu上有两套管理网络的系统，一个是interfaces文件（网络设置由配置文件决定）和NetworkManager（网络设置由图形界面决定），它们二者之间只能使用一个，所以，在需要修改interfaces的时候（比如固定ip），要先把NetworkManager的服务屏蔽掉，service network-manager stop.之所以遇到这样的问题就是在修改interfaces之前没有对NetworkManager进行管理<br><br>wlan0比较复杂，先尝试开启并连上网络<br><br>1.. 打开无线网卡电源<br><br>iwconfig wlan0 txpower on 或者 sudo ip link set wlan0 up<br><br>列出区域内的无线网络<br>iwlist wlan0 scan 或者 sudo iw dev wlan0 scan | less<br><br>3.连接wifi<br><br>假如wifi没有加密：sudo iw dev wlan0 connect [网络 SSID]<br><br>假如是WEP加密：sudo iw dev wlan0 connect [网络 SSID] key 0:[WEP 密钥]<br><br>假如是WPA或者WPA2加密的话，就比较麻烦了，需要借助wpasupplicant这个工具<br><br>编辑_/etc/wpa_supplicant/wpa_supplicant.conf<br><br><font color="#0099ff"><br>network={<br><br>ssid=”[网络 ssid]“<br><br>psk=”[密码]“<br><br>priority=1<br><br>}<br></font>

<p>重启网络</p>
<p>后台开启：sudo wpa_supplicant -i wlan0 -c /etc/wpa_supplicant/wpa_supplicant.conf</p>
<p>然后dhcp获取：sudo dhclient wlan0 或 sudo dhcpcd wlan0</p>
<p>如果正常的话，查看wlan0信息，输入<br>iwconfig wlan0</p>
<p>启用无线网卡<br>ifconfig wlan0 up</p>
<p>如果是用DHCP获取IP的，那么用dhclient 或dhcpcd获取ip<br>dhclient wlan0</p>
<p>或</p>
<p>dhcpcd wlan0</p>
<p>&emsp;通过interfaces适合修改server版的linux，对于平常个人使用不方便，因为假如要连接新的wifi，每次都要新增配置文件，那么如何恢复原来的图形界面，也就是NetworkManager呢</p>
<p>首先要确保自己的图形界面设置没有修改过</p>
<p>比如/etc/dbus-1/system.d/org.freedesktop.NetworkManager.conf</p>
<font cokor="#DC143C"><br>cat /etc/dbus-1/system.d/org.freedesktop.NetworkManager.conf<br></font><br><font face="黑体" color="#0099ff"><br>&lt;!DOCTYPE busconfig PUBLIC<br><br>“-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN”<br><br>“<a href="http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd&quot;&gt;" target="_blank" rel="external">http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd&quot;&gt;</a>;<br><br><busconfig><br><br>&lt;policy user=”root”&gt;<br><br>            &lt;allow own=”org.freedesktop.NetworkManager”/&gt;<br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager”/&gt;<br><br><br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.NetworkManager.PPP”/&gt;<br><br><br><br>            &lt;allow send_interface=”org.freedesktop.NetworkManager.SecretAgent”/&gt;<br><br><br><br>            &lt;!– Allow NM to talk to known VPN plugins; due to a bug in<br><br>                 the D-Bus daemon, when a plugin is installed and the user<br><br>                 immediately tries to use it, the VPN plugin’s rules aren’t<br><br>                 always loaded into dbus-daemon.  Those rules allow NM to<br><br>                 talk to the plugin.  Oops.  Work around that by explicitly<br><br>                 allowing NM to talk to VPN plugins here.<br><br>              –&gt;<br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager.openconnect”/&gt;<br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager.openswan”/&gt;<br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager.openvpn”/&gt;<br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager.pptp”/&gt;<br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager.vpnc”/&gt;<br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager.ssh”/&gt;<br><br><br><br>            &lt;!– Allow the custom name for the dnsmasq instance spawned by NM<br><br>                 from the dns dnsmasq plugin to own it’s dbus name, and for<br><br>                 messages to be sent to it.<br><br>             –&gt;<br><br>            &lt;allow own=”org.freedesktop.NetworkManager.dnsmasq”/&gt;<br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager.dnsmasq”/&gt;<br><br>    &lt;/policy&gt;<br><br>    &lt;policy at_console=”true”&gt;<br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager”/&gt;<br><br><br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.DBus.Introspectable”/&gt;<br><br><br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.DBus.Properties”/&gt;<br><br><br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.NetworkManager”/&gt;<br><br><br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.NetworkManager.AccessPoint”/&gt;<br><br><br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.NetworkManager.Connection.Active”/&gt;<br><br><br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.NetworkManager.Device.Modem”/&gt;<br><br><br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.NetworkManager.Device.Wired”/&gt;<br><br><br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.NetworkManager.Device.Serial”/&gt;<br><br><br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.NetworkManager.Device.Wireless”/&gt;<br><br><br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.NetworkManager.Device”/&gt;<br><br><br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.NetworkManager.DHCP4Config”/&gt;<br><br><br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.NetworkManager.IP4Config”/&gt;<br><br><br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.NetworkManager.VPN.Connection”/&gt;<br><br><br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.NetworkManager.AgentManager”/&gt;<br><br><br><br>            &lt;deny send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.NetworkManager”<br><br>                   send_member=”SetLogging”/&gt;<br><br><br><br>            &lt;deny send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.NetworkManager”<br><br>                   send_member=”Sleep”/&gt;<br><br><br><br>            &lt;deny send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.NetworkManager”<br><br>                   send_member=”sleep”/&gt;<br><br><br><br>            &lt;deny send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.NetworkManager”<br><br>                   send_member=”wake”/&gt;<br><br>    &lt;/policy&gt;<br><br>    &lt;policy user=”whoopsie”&gt;<br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager”/&gt;<br><br><br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.DBus.Introspectable”/&gt;<br><br><br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.DBus.Properties”/&gt;<br><br><br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.NetworkManager”/&gt;<br><br><br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.NetworkManager.Connection.Active”/&gt;<br><br><br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.NetworkManager.Device”/&gt;<br><br>    &lt;/policy&gt;<br><br>    &lt;policy context=”default”&gt;<br><br>            &lt;deny own=”org.freedesktop.NetworkManager”/&gt;<br><br><br><br>            &lt;deny send_destination=”org.freedesktop.NetworkManager”/&gt;<br><br><br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.NetworkManager.Settings”/&gt;<br><br><br><br>            &lt;allow send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.NetworkManager.AgentManager”/&gt;<br><br><br><br>            &lt;deny send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.NetworkManager”<br><br>                   send_member=”SetLogging”/&gt;<br><br><br><br>            &lt;deny send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.NetworkManager”<br><br>                   send_member=”Sleep”/&gt;<br><br><br><br>            &lt;deny send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.NetworkManager”<br><br>                   send_member=”sleep”/&gt;<br><br><br><br>            &lt;deny send_destination=”org.freedesktop.NetworkManager”<br><br>                   send_interface=”org.freedesktop.NetworkManager”<br><br>                   send_member=”wake”/&gt;<br><br><br><br>            &lt;deny own=”org.freedesktop.NetworkManager.dnsmasq”/&gt;<br><br>            &lt;deny send_destination=”org.freedesktop.NetworkManager.dnsmasq”/&gt;<br><br>    &lt;/policy&gt;<br></busconfig><br></font>

<p>然后还有/etc/xdg/autostart/nm-applet.desktop：</p>
<font color="#0099ff"><br>[Desktop Entry]<br><br>Name=Network<br><br>Comment=Manage your network connections<br><br>Icon=nm-device-wireless<br><br>Exec=nm-applet<br><br>Terminal=false<br><br>Type=Application<br><br>NoDisplay=true<br><br>NotShowIn=KDE;<br><br>X-GNOME-Bugzilla-Bugzilla=GNOME<br><br>X-GNOME-Bugzilla-Product=NetworkManager<br><br>X-GNOME-Bugzilla-Component=nm-applet<br><br>X-GNOME-UsesNotifications=true<br><br>AutostartCondition=GNOME3 unless-session gnome<br><br>X-Ubuntu-Gettext-Domain=nm-applet<br><br></font><br>网上有种说法：<a href="http://blog.csdn.net/cor\_twi/article/details/43836681" target="_blank" rel="external">http://blog.csdn.net/cor\_twi/article/details/43836681</a><br><br>但是按照这种做法没有用<br><br>如果要用图形界面，到/etc/NetworkManager/nm-system-settings.conf下，把<br><br>[ifupdown]<br><br>managed=false（应该是修改了interfaces之后自动改成false的）<br><br>中的false改成true<br><br>&emsp;上述的方法能够重新使用有线和无线，但是也有留下不少的问题没有解决，比如开机的时候就要比平时等多2–3分钟（猜测是修改了配置之后通过NetworkManager管理网络的话是不会保留上一次工作的网络信息，然后导致本次开机重新加载），而且要通过图形界面配置网络的话，要在开机的时候输入：<br><br>sudo service network-manager restart<br><br>而且，此时的图形控制栏是缺少了一些功能的，比如关闭wifi，比如vpn配置，假如要关闭wifi，就通过sudo ifdown wlan0。<br><br>假如是要配置vpn，也可以通过命令行实现，下面有两个方法：<br><br>方法1：<br><br>sudo pptpsetup –create testvpn –server 123.45.67.88 –username kk –password fku –encrypt –start<br><br>&emsp;–create 后的是创建的连接名称，可以为任意名称; –server 后接的是vpn服务器的IP; –username 是用户名 –password 是密码，在这也可以没这个参数，命令稍后会自动询问。这样可以保证账号安全 –encrypt 是表示需要加密，不必指定加密方式，命令会读取配置文件中的加密方式 –start 是表示创建连接完后马上连接，如果你不想连，就不写<br><br>连接：sudo pon vpnname<br><br>查看状态：plog<br><br>断开：sudo poff<br><br>方法2：<br><br>连接：<br><br>~$ sudo nmcli -p c up id VPN-Green<br><br>断开连接：<br><br>~$ sudo nmcli -p c down id VPN-Green<br><br>修改/etc/NetworkManagersystem-connections/VPN-Green<br><br><font color="#FF7F50"><br>password-flags=0<br><br>[vpn-secrets]<br><br>password=<strong><em>*</em></strong><br><br>[connection]<br><br>id=VPN-Green （名字）<br><br>uuid=9b17f157-fb28-42bf-b092-d3e4a56682f1<br><br>type=vpn<br><br>permissions=user:tomcat:;<br><br>autoconnect=false<br><br>timestamp=1444354237<br><br>[vpn]<br><br>service-type=org.freedesktop.NetworkManager.pptp<br><br>gateway=a.sggjsq.com<br><br>require-mppe=yes<br><br>user=<strong><em>*</em></strong><br><br>password-flags=0<br><br>[vpn-secrets]<br><br>password=<strong><em>*</em></strong><br><br>[ipv4]<br><br>method=auto<br><br></font>

<p>参考：<a href="http://int32bit.me/2016/04/18/Linux%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E6%80%BB%E7%BB%93/" target="_blank" rel="external">http://int32bit.me/2016/04/18/Linux%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E6%80%BB%E7%BB%93/</a></p>
<p><a href="https://linux.cn/article-4015-1.html" target="_blank" rel="external">https://linux.cn/article-4015-1.html</a></p>
<p><a href="http://blog.chinaunix.net/uid-108431-id-4096909.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-108431-id-4096909.html</a></p>
<p>vpn设置和命令：<a href="http://blog.sina.com.cn/s/blog_630d9b440100fjpu.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_630d9b440100fjpu.html</a></p>
<p>（参照上面三个完成）</p>
<p><a href="http://wiki.ubuntu.org.cn/UbuntuManual:%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE\#.E9.85.8D.E7.BD.AE.E6.97.A0.E7.BA.BF.E7.BD.91.E5.8D.A1.28Wi-Fi.29.E6.8E.A5.E5.8F.A3" target="_blank" rel="external">http://wiki.ubuntu.org.cn/UbuntuManual:%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE\#.E9.85.8D.E7.BD.AE.E6.97.A0.E7.BA.BF.E7.BD.91.E5.8D.A1.28Wi-Fi.29.E6.8E.A5.E5.8F.A3</a></p>
<p><a href="https://wiki.debian.org/zh\_CN/NetworkConfiguration" target="_blank" rel="external">https://wiki.debian.org/zh\_CN/NetworkConfiguration</a></p>
<p><a href="http://www.cnblogs.com/xuanfengling/p/3410551.html" target="_blank" rel="external">http://www.cnblogs.com/xuanfengling/p/3410551.html</a></p>
<p><a href="http://blog.csdn.net/pkueecser/article/details/7165865" target="_blank" rel="external">http://blog.csdn.net/pkueecser/article/details/7165865</a></p>
<p>来源： <a href="https://www.gitbook.com/book/simonid/linux/edit#/edit/master/记录一次关于networkmanager和interfaces的问题.md?_k=qmiwfi" target="_blank" rel="external">https://www.gitbook.com/book/simonid/linux/edit#/edit/master/记录一次关于networkmanager和interfaces的问题.md?_k=qmiwfi</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&lt;h3&gt;记录一次NetworkManager与interfaces冲突的解决&lt;/h3&gt;&lt;br&gt;&lt;br/&gt;&lt;br&gt;&amp;emsp;主机是ubuntu14.04，之前改过/etc/network/interfaces的配置内容（设置了静态ip），然后发现图形界面上的网络设置失效了，而且因为修改了interfaces之后还不能连接网络，ifconfig的时候不显示wlan0和eth0的信息，反而多了一个tun0-00。下面是一些解决的步骤：&lt;/p&gt;
&lt;p&gt;&amp;emsp;首先，重新编辑interfaces文件和/etc/resolv.conf文件，使他们恢复默认设置，然后重启，失败。先解决eth0的问题吧。网线接上电脑，手动开启eth0：&lt;/p&gt;
&lt;p&gt;sudo ip link set eth0 up 或 sudo ifconfig eth0 up&lt;/p&gt;
&lt;p&gt;&amp;emsp;再查看一下，ifconfig，如果没有ipv4地址，尝试：&lt;br/&gt;&lt;/p&gt;
&lt;font color=#DC143C&gt;&lt;br&gt;sudo dhclient eth0&lt;br&gt;&lt;/font&gt;&lt;br/&gt;&lt;br&gt;&amp;emsp;然后ping一下同网段ip，失败的话，尝试nc命令&lt;br&gt;&lt;br&gt;&amp;emsp;如果ICMP被禁了，使用nc命令或者telnet更适合，且可以探测端口是否开放,虽然DHCP端口是67，不过通常DHCP和DNS服务器是同一台机器，因此顺便测试53端口：&lt;br&gt;&lt;br&gt;nc -zv 192.168.1.1 67&lt;br&gt;&lt;br&gt;nc -zv 192.168.1.1 53&lt;br&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://simonid.github.io/2017/03/16/hello-world/"/>
    <id>https://simonid.github.io/2017/03/16/hello-world/</id>
    <published>2017-03-16T05:47:41.915Z</published>
    <updated>2017-01-16T06:15:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>单个git工具配置多个代码托管账号</title>
    <link href="https://simonid.github.io/2017/03/16/%E5%8D%95%E4%B8%AAgit%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E8%B4%A6%E5%8F%B7/"/>
    <id>https://simonid.github.io/2017/03/16/单个git工具配置多个代码托管账号/</id>
    <published>2017-03-16T01:36:45.000Z</published>
    <updated>2017-03-16T05:40:41.000Z</updated>
    
    <content type="html"><![CDATA[<p></p><h2><center>单个git工具配置多个代码托管账号</center></h2><br>最近在使用hexo的时候遇到了一个麻烦，本人平时用两台电脑，ubuntu和windows，在ubuntu上已经建立了一个hexo项目（基于github），然后想再windows上也能写hexo博客，但是这样就要反复地git pull。为了避免麻烦，可以使用oschina账号或者另外一个github账号也发布一个博客。但是在win上的git工具之前已经配置了github账号了，怎么设置多账号不冲突？<br><br>首先取消之前的全局配置:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global --unset user.name</div><div class="line">git config --global --unset user.email</div></pre></td></tr></table></figure><p></p>
<p>ssh秘钥生成：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C &quot;email&quot;</div></pre></td></tr></table></figure></p>
<p>添加ssh key：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-add -K ~/.ssh/id_rsa</div></pre></td></tr></table></figure></p>
<p>删除key方法：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-add -D</div></pre></td></tr></table></figure></p>
<p>查看key设置<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ssh-add -l</div><div class="line">```  </div><div class="line">新建ssh config文件：&lt;br/&gt;</div></pre></td></tr></table></figure></p>
<p>vim ~/.ssh/config</p>
<p>vonfig文件格式：</p>
<h1 id="Default-github-user-A-mail-com-注意User项直接填git，不用填在github的用户名"><a href="#Default-github-user-A-mail-com-注意User项直接填git，不用填在github的用户名" class="headerlink" title="Default github user(A@mail.com),注意User项直接填git，不用填在github的用户名"></a>Default github user(A@mail.com),注意User项直接填git，不用填在github的用户名</h1><p>Host A.github.com  #自定义<br> HostName github.com#固定<br> User git  #自定义<br> IdentityFile ~/.ssh/id_rsa_github_A</p>
<h1 id="second-user-B-mail-com"><a href="#second-user-B-mail-com" class="headerlink" title="second user(B@mail.com)"></a>second user(B@mail.com)</h1><h1 id="建一个gitlab别名，新建的帐号使用这个别名做克隆和更新"><a href="#建一个gitlab别名，新建的帐号使用这个别名做克隆和更新" class="headerlink" title="建一个gitlab别名，新建的帐号使用这个别名做克隆和更新"></a>建一个gitlab别名，新建的帐号使用这个别名做克隆和更新</h1><p>Host A.github.com<br> HostName github.com<br> User git<br> IdentityFile ~/.ssh/id_rsa_github_B<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">如果不按照格式设置，就会出现：&lt;br/&gt;</div></pre></td></tr></table></figure></p>
<p>ERROR: Permission to two/two.github.com.git denied to one.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;因为ssh 客户端是通过类似:</div><div class="line">git@github.com:one/one.github.com.git</div><div class="line">这样的 git 地址中的 User 和 Host 来识别使用哪个本地私钥的。&lt;br/&gt;</div><div class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;很明显，如果 User 和 Host 始终为 git 和 github.com，那么就只能使用一个私钥。&lt;br/&gt;</div><div class="line">&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;所以需要上面的方式配置，每个账号使用了自己的 Host，每个 Host 的域名做 CNAME 解析到 github.com，这样 ssh 在连接时就可以区别不同的账号了&lt;br/&gt;</div><div class="line">测试：&lt;br/&gt;</div></pre></td></tr></table></figure></p>
<p>ssh -T git@github.com        # 测试one ssh连接</p>
<p>#Hi <em>*</em>! You’ve successfully authenticated, but GitHub does not provide shell access.<br>ssh -T git@two.github.com    # 测试two ssh连接</p>
<p>#Hi <em>*</em>! You’ve successfully authenticated, but GitHub does not provide shell access.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在各自账号中配置：&lt;br/&gt;</div></pre></td></tr></table></figure></p>
<p>git config user.name “name”            # <strong>name</strong> 例如 one<br>git config user.email “email”</p>
<p>git config –list  #检测配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">也可以：&lt;br/&gt;</div></pre></td></tr></table></figure></p>
<p>git remote add github A.github.com(输入的是config文件的Host选项) git@github.com:username/project.git<br>repo init -u ssh://A@github.com -b branch</p>
<p>#push的时候到对应的host<br>git push A.github.com master<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">如果push的时候遇到：&lt;br/&gt;</div></pre></td></tr></table></figure></p>
<p>warning: push.default is unset; its implicit value is changing in Git 2.0 from ‘matching’ to ‘simple’. To squelch this messageand maintain the current behavior after the default changes, use…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">推荐使用：&lt;br/&gt;</div></pre></td></tr></table></figure></p>
<p>git config –global push.default simple<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">假如clone没有问题，push的时候总是报错:&lt;br/&gt;</div></pre></td></tr></table></figure></p>
<p>error: The requested URL returned error: 403 while accessing xxx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">解决：&lt;br/&gt;</div><div class="line">修改 repo/.git/config 里面的url，把https地址替换为ssh就好了&lt;br/&gt;</div><div class="line">比如：&lt;br/&gt;</div></pre></td></tr></table></figure></p>
<p>url=<a href="https://MichaelDrogalis@github.com/derekerdmann/lunch_call.git" target="_blank" rel="external">https://MichaelDrogalis@github.com/derekerdmann/lunch_call.git</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">替换为：&lt;br/&gt;</div></pre></td></tr></table></figure></p>
<p>url=ssh://git@github.com/derekerdmann/lunch_call.git<br>```</p>
<p>参考：<br><br><a href="http://tmyam.github.io/blog/2014/05/07/duo-githubzhang-hu-she-zhi/" target="_blank" rel="external">http://tmyam.github.io/blog/2014/05/07/duo-githubzhang-hu-she-zhi/</a><br><br><a href="http://memoryboxes.github.io/blog/2014/12/07/duo-ge-gitzhang-hao-zhi-jian-de-qie-huan/" target="_blank" rel="external">http://memoryboxes.github.io/blog/2014/12/07/duo-ge-gitzhang-hao-zhi-jian-de-qie-huan/</a><br><br><a href="http://www.imooc.com/article/7419" target="_blank" rel="external">http://www.imooc.com/article/7419</a><br><br><a href="http://yyblog.mocoer.com/2014/08/25/%E5%A4%9Agithub%E8%B4%A6%E5%8F%B7SSH%20key%E5%88%87%E6%8D%A2%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">http://yyblog.mocoer.com/2014/08/25/%E5%A4%9Agithub%E8%B4%A6%E5%8F%B7SSH%20key%E5%88%87%E6%8D%A2%E4%BD%BF%E7%94%A8/</a><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;center&gt;单个git工具配置多个代码托管账号&lt;/center&gt;&lt;/h2&gt;&lt;br&gt;最近在使用hexo的时候遇到了一个麻烦，本人平时用两台电脑，ubuntu和windows，在ubuntu上已经建立了一个hexo项目（基于github），然后想再windo
    
    </summary>
    
    
      <category term="git" scheme="https://simonid.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>hexo多仓库部署以及DNS分流</title>
    <link href="https://simonid.github.io/2017/03/16/hexo%E5%A4%9A%E4%BB%93%E5%BA%93%E9%83%A8%E7%BD%B2%E4%BB%A5%E5%8F%8ADNS%E5%88%86%E6%B5%81/"/>
    <id>https://simonid.github.io/2017/03/16/hexo多仓库部署以及DNS分流/</id>
    <published>2017-03-16T01:08:56.000Z</published>
    <updated>2017-03-16T01:27:10.000Z</updated>
    
    <content type="html"><![CDATA[<p></p><h2><center>hexo多仓库部署以及DNS分流</center></h2><br><a href="http://www.xyzardq.com/2016/11/14/Hexo%E5%A4%9Arepositories%E9%83%A8%E7%BD%B2%E5%8F%8ADNS%E5%88%86%E6%B5%81/" target="_blank" rel="external">参考原文</a><br><br><p></p>
<p><hr><br><br><br>hexo可以搭配github page搭建博客，但是github在国内的访问速度有限，我们可以考虑将hexo项目同时部署到oschina或者coding这些国内代码托管平台，通过DNSPod分流访问。<br><br>要发布到代码托管平台，首先安装组件:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git –save</div></pre></td></tr></table></figure></p>
<p>在根目录配置文件下修改deploy,格式：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: &lt;repository url&gt;</div><div class="line">  branch: [branch]</div><div class="line">  message: [message]</div></pre></td></tr></table></figure></p>
<p>参数描述：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">repo 	库(Repository)地址</div><div class="line">branch 	分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测</div><div class="line">message 	自定义提交信息 (默认为 Site updated: &#123;&#123; now(’YYYY-MM-DD HH:mm:ss’) &#125;&#125;)</div></pre></td></tr></table></figure></p>
<p>如果是发布到多个平台：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">- type: git</div><div class="line">  repo: &lt;repository url&gt;,[branch]</div><div class="line">- type: git</div><div class="line">  repo: &lt;repository url&gt;,[branch]</div></pre></td></tr></table></figure></p>
<p>其中，repositories（仓库）的地址有两种形式：<br>第一种是https，类似<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/xyzardq/xyzardq.github.io.git</div></pre></td></tr></table></figure></p>
<p>第二种是SSH，类似<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git@github.com:xyzardq/xyzardq.github.io.git</div></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;&ensp;&ensp;这两种仓库地址有什么区别呢？https是在部署时直接通过https协议push到对应的repositories，所以在push的时候需要输入仓库所对应的代码托管平台的账号密码。而SSH是在部署时用云端的公匙解锁本地的私匙，如果对应就直接push到对应的repositories，从而不用输入账户密码。本人比较推荐用SSH，毕竟不用输入密码比较方便。<br></p>
<p></p><h3><center>DNS分流</center></h3><br>注册DNSPod：<a href="https://www.dnspod.cn/" target="_blank" rel="external">DNSPod</a><br><br>&ensp;&ensp;&ensp;&ensp;现在，我们已经把Blog部署到了两个以上的平台上，那么，怎样才能根据访客不同的线路类型解析到不同的page上呢？这时就需要域名的DNS解析分流了。据我所知，目前DNSPod和cloudxds都支持DNS分流。DNSPod的免费版就支持DNS解析分流，但是缺点是免费版显性转址需要网站正常代理满30天….30天过去黄花菜都凉了，不过CNAME不受此限制。cloudxds的免费版号称DNSPod的收费版，但是缺点是没备案的域名用不了…所以如果是没备案的域名只能使用DNSPod了。下面以DNSpod为例。<br><br><p></p>
<p><font color="darkgreen" size="4">添加CNAME记录</font></p>
<p><ul></ul></p>
<p><li>添加要解析的域名</li><br>ps:填写的域名不要带www前缀</p>
<p><li>添加CNAME记录</li><br>由于我们要进行DNS分流解析，所以一般来说需要添加两条以上的CNAME记录，下面以分为国外和国内两条线路为例<br><br>ps:除了国外和国内，DNSPod还提供电信移动联通等运营商和谷歌百度等搜索引擎的线路提供<br><br>修改NS记录<br></p>
<p><font color="darkgreen" size="4">什么是NS记录？</font><br></p>
<pre><code>NS记录（name server）即域名服务器记录，用于指定该域名由哪个 DNS 服务器进行域名解析。注册域名时，总会有默认的 NS 记录。
</code></pre><p><br><br>ps:如果是在DNSPod注册的域名，请跳过此步。<br></p>
<p><ul><br>    <li>记下DNSPod的域名服务器</li><br>    DNSPod的域名服务器存储在控制台的DNS记录中，默认为<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">f1g1ns1.dnspod.net</div><div class="line">f1g1ns2.dnspod.net</div></pre></td></tr></table></figure></ul></p>
<p>   <li>修改所用域名注册商的域名服务器</li><br>    登录所用域名的域名注册商，进入DNS管理，将域名服务器（有的注册商为DNS记录中的NS记录）修改为DNSPod的域名服务器<br></p>
<p>   <li>测试DNS解析是否生效</li><br>    打开<a href="http://tool.chinaz.com/dns/" target="_blank" rel="external">Dns检测|Dns查询- 站长工具</a>，输入你的域名，选择CNAME类型，检测。如果国内国外的响应IP分别为你设置的两个记录值，则DNS分流设置成功<br><br> <br><br><br><br><br>另附上参考：<br><br><a href="http://ppting.me/2015/02/08/gitcafe/" target="_blank" rel="external">同时将博客部署在Github和Gitcafe上，并通过DNSPOD分流</a><br><a href="http://www.cnblog.me/2015/04/26/dnspod/" target="_blank" rel="external">使用 DNSPod 解决 GoDaddy 域名解析不稳定的问题</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;center&gt;hexo多仓库部署以及DNS分流&lt;/center&gt;&lt;/h2&gt;&lt;br&gt;&lt;a href=&quot;http://www.xyzardq.com/2016/11/14/Hexo%E5%A4%9Arepositories%E9%83%A8%E7%BD%B2%
    
    </summary>
    
    
      <category term="hexo" scheme="https://simonid.github.io/tags/hexo/"/>
    
      <category term="博客" scheme="https://simonid.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Linux创建共享目录</title>
    <link href="https://simonid.github.io/2017/03/16/Linux%E5%88%9B%E5%BB%BA%E5%85%B1%E4%BA%AB%E7%9B%AE%E5%BD%95/"/>
    <id>https://simonid.github.io/2017/03/16/Linux创建共享目录/</id>
    <published>2017-03-15T16:10:00.000Z</published>
    <updated>2017-03-15T16:17:31.000Z</updated>
    
    <content type="html"><![CDATA[<p></p><h2><center>Linux创建共享目录</center></h2><br>如果你是管理员，想给其他人针对某个目录的权限，那么就要划定一个有一定权限的用户组和该目录绑定<br><br>先创建目录和用户组:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo mkdir -p /var/www/reports/</div><div class="line">$ sudo groupadd project</div></pre></td></tr></table></figure><p></p>
<p>将对目录 /var/www/reports/ 有写权限的用户添加到 project 组中<br><br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo usermod -a -G project tecmint</div></pre></td></tr></table></figure></p>
<p>上面命令使用到的标志和参数是：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-a – 将用户添加到增补组中。</div><div class="line">-G – 指定组名。</div><div class="line">project – 组名。</div><div class="line">tecmint – 已有的用户名。</div></pre></td></tr></table></figure></p>
<p>递归权限赋予:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo chgrp -R project /var/www/reports/</div><div class="line">$ sudo chmod -R 2775 /var/www/reports/</div></pre></td></tr></table></figure></p>
<p>解释下上面 chmod 命令中的 2775：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">2 - 打开 setGID 位，意味着新创建的子文件继承与目录相同的组，新创建的子目录继承父目录的 setGID 位。</div><div class="line">7 - 为所有者提供 rwx 权限。</div><div class="line">7 - 给组 rwx 权限。</div><div class="line">5 - 为其他人提供 rx 权限。</div></pre></td></tr></table></figure></p>
<p>可以使用下面的命令创建更多的系统用户并将它们添加到目录组中：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo useradd -m -c &quot;Aaron Kili&quot; -s/bin/bash -G project aaronkilik</div><div class="line">$ sudo useradd -m -c &quot;John Doo&quot; -s/bin/bash -G project john</div><div class="line">$ sudo useradd -m -c &quot;Ravi Saive&quot; -s/bin/bash -G project ravi</div></pre></td></tr></table></figure></p>
<p>接着创建每个用户存储他们项目报告的子目录<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo mkdir -p /var/www/reports/aaronkilik_reports</div><div class="line">$ sudo mkdir -p /var/www/reports/johndoo_reports</div><div class="line">$ sudo mkdir -p /var/www/reports/ravi_reports</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;h2&gt;&lt;center&gt;Linux创建共享目录&lt;/center&gt;&lt;/h2&gt;&lt;br&gt;如果你是管理员，想给其他人针对某个目录的权限，那么就要划定一个有一定权限的用户组和该目录绑定&lt;br/&gt;&lt;br&gt;先创建目录和用户组:&lt;br/&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ sudo mkdir -p /var/www/reports/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ sudo groupadd project&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;将对目录 /var/www/reports/ 有写权限的用户添加到 project 组中&lt;br/&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://simonid.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>django之mvc</title>
    <link href="https://simonid.github.io/2017/03/15/django%E4%B9%8Bmvc/"/>
    <id>https://simonid.github.io/2017/03/15/django之mvc/</id>
    <published>2017-03-15T15:05:57.000Z</published>
    <updated>2017-03-15T15:53:24.000Z</updated>
    
    <content type="html"><![CDATA[<p></p><h2><center>django之mvc</center></h2><br>推荐：<a href="http://morningchen.com/tags/Django/" target="_blank" rel="external">http://morningchen.com/tags/Django/</a><br><p></p>
<p><hr><br>MVC(Model View Controller 模型-视图-控制器)是一种web架构模型，将业务逻辑、模型数据、用户界面分离，前端开发只要负责页面部分，后端开发只要负责后台管理和数据库。<br><br>model:将客观实物抽象为对象，由类产生多种方法。<br><br>view:视图，呈现的内容基于model，也负责收集用户输入。<br><br>controller：model和view之间的媒介。<br><br><a id="more"></a><br>MVC是单向的，过程：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">浏览器发起请求</div><div class="line">controller和model交互获取数据</div><div class="line">controller调用view</div><div class="line">view渲染数据返回</div></pre></td></tr></table></figure></p>
<p>开发web需要的组件：<br></p>
<pre><code>数据库的对象关系映射（ORM,Object-Relation Maping）&lt;br/&gt;
动态内容管理的模板系统&lt;br/&gt;
丰富自动化的管理界面&lt;br/&gt;
</code></pre><p>模型图：<br><br><img src="http://photo1-1253196505.cosgz.myqcloud.com/photo/mvc%E6%A8%A1%E5%9E%8B.png?sign=L7kmnGC91ys7AlJ8eUI4ABC09SlhPTEyNTMxOTY1MDUmaz1BS0lESFVaUzkwUU5CZjRRbjlFdjA3QktPV2RueXZ6c2F3blcmZT0xNDkyMTg0OTIxJnQ9MTQ4OTU5MjkyMSZyPTg1NTU2NjY3NCZmPS9waG90by9tdmMlRTYlQTglQTElRTUlOUUlOEIucG5nJmI9cGhvdG8x" alt="mvc"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">优点：</div><div class="line"></div><div class="line">    可以为一个模型在运行的同时建立和使用多个视图</div><div class="line">    视图与控制器的可插拔性</div><div class="line">    模型的可移植性</div><div class="line">    潜在的框架结构</div><div class="line"></div><div class="line">缺点：</div><div class="line"></div><div class="line">    增加了系统结构和实现的复杂性</div><div class="line">    视图与控制器连接过于紧密</div><div class="line">    视图对模型数据的低效率访问</div><div class="line">    高级界面工具不支持MVC模式</div></pre></td></tr></table></figure></p>
<p>Django框架中的 MVC实现方式：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">    当URL被请求 ➜ 调用指定的Python方法 ➜ 通过业务逻辑(model)处理 ➜ 经过模板(template) ➜ 呈现页面(view)</div><div class="line"></div><div class="line">这种实现方式在Django中称为 MVT(Model-View-Template)</div></pre></td></tr></table></figure></p>
<p><img src="http://photo1-1253196505.cosgz.myqcloud.com/photo/django-mvc.png?sign=xb99fWUduf6Fl2z68sTFfCskKb9hPTEyNTMxOTY1MDUmaz1BS0lESFVaUzkwUU5CZjRRbjlFdjA3QktPV2RueXZ6c2F3blcmZT0xNDkyMTg1MDg2JnQ9MTQ4OTU5MzA4NiZyPTE0OTk0MTIzNDAmZj0vcGhvdG8vZGphbmdvLW12Yy5wbmcmYj1waG90bzE=" alt="django-mvc"></p>
<p>参考链接:<a href="http://morningchen.com/2015/04/08/Django-MVC/" target="_blank" rel="external">http://morningchen.com/2015/04/08/Django-MVC/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;h2&gt;&lt;center&gt;django之mvc&lt;/center&gt;&lt;/h2&gt;&lt;br&gt;推荐：&lt;a href=&quot;http://morningchen.com/tags/Django/&quot;&gt;http://morningchen.com/tags/Django/&lt;/a&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;hr/&gt;&lt;br&gt;MVC(Model View Controller 模型-视图-控制器)是一种web架构模型，将业务逻辑、模型数据、用户界面分离，前端开发只要负责页面部分，后端开发只要负责后台管理和数据库。&lt;br/&gt;&lt;br&gt;model:将客观实物抽象为对象，由类产生多种方法。&lt;br/&gt;&lt;br&gt;view:视图，呈现的内容基于model，也负责收集用户输入。&lt;br/&gt;&lt;br&gt;controller：model和view之间的媒介。&lt;br/&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://simonid.github.io/tags/python/"/>
    
      <category term="django" scheme="https://simonid.github.io/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>hexo主题定制2</title>
    <link href="https://simonid.github.io/2017/03/15/hexo%E4%B8%BB%E9%A2%98%E5%AE%9A%E5%88%B62/"/>
    <id>https://simonid.github.io/2017/03/15/hexo主题定制2/</id>
    <published>2017-03-15T13:17:57.000Z</published>
    <updated>2017-03-15T15:52:28.000Z</updated>
    
    <content type="html"><![CDATA[<p></p><h2><center>hexo主题定制2</center></h2><p></p>
<p><font color="darkgreen" size="5">博主推荐：</font><br><br><a href="http://moxfive.xyz" target="_blank" rel="external">http://moxfive.xyz</a><br><br><a href="http://gaomf.cn" target="_blank" rel="external">http://gaomf.cn</a><br><br><a href="http://www.xyzardq.com" target="_blank" rel="external">http://www.xyzardq.com</a><br></p>
<p><hr><br><br><br>主题介绍：<br><br>Yelee:<br><br><a href="http://moxfive.coding.me/yelee/" target="_blank" rel="external">http://moxfive.coding.me/yelee/</a><br></p>
<p><hr><br><br></p>
<p><font color="red" size="4">设置代码高亮</font><br><br>在反引号后面紧跟着语言名称就可以了，比如c语言<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"hello word\n"</span>);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在反引号后面加上c<br></p>
<p><font color="red" size="4">添加单独页面，比如自我介绍</font><br><br>&ensp;&ensp;首先在根目录下的public/categories目录下找到相关目录，然后再添加md文件，在到主题目录下找到配置文件，在其中的menu下自定义选项，注意路径一定要正确<br><br><a id="more"></a></p>
<p><font color="red" size="4">自定义侧边栏自我介绍</font><br><br>&ensp;&ensp;相关文件在left-col.ejs下，比如我要添加两段文字,可以：<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;hgroup&gt;</div><div class="line">		  &lt;h1 class="header-author"&gt;&lt;a href="/" class="alluraregular"&gt;&lt;%=theme.author%&gt;&lt;/a&gt;&lt;/h1&gt;</div><div class="line">		&lt;/hgroup&gt;</div><div class="line"></div><div class="line">		&lt;p class="header-subtitle"&gt;纵有疾风起 | 人生不言弃&lt;/p&gt;</div></pre></td></tr></table></figure></p>
<p>相关的样式文件是main.styl<br></p>
<p><font color="red" size="4">自定义标签</font><br><br>相关样式文件是tagcloud.styl<br></p>
<p><font color="red" size="4">添加RSS插件</font><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-generator-feed --sava</div></pre></td></tr></table></figure></p>
<p>然后到主题目录下的配置文件中的subnav选项下新增选项，比如：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">subnav:</div><div class="line">  rss:&quot;/atom.xml&quot;</div></pre></td></tr></table></figure></p>
<p>hexo g之后可以在public下看到新增的atom.xml<br></p>
<p><font color="red" size="4">新增目录</font><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo new page ... :新增目录</div></pre></td></tr></table></figure></p>
<p>在/themes/yilia/layout/_partial/article.ejs里修改。将下面代码放在&lt;%- post.content %&gt;之上<br><br>这一段内容参考自：<a href="http://www.xyzardq.com/2016/11/04/Hexo%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">参考</a><br><br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;% <span class="keyword">if</span>(post.toc == <span class="literal">true</span>)&#123; %&gt;</div><div class="line">&lt;div id="toc" class="toc-article"&gt;</div><div class="line">  &lt;strong class="toc-title"&gt;文章目录&lt;/strong&gt;</div><div class="line">&lt;%- toc(post.content, &#123;list_number: false&#125;) %&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure></p>
<p>这其中加了一个判断，默认是不加目录的（当然你也可以改成post.toc == false，这样默认就是添加目录的情况啦），如果想在文章中使用目录的话，可以在 front-matter里加上 toc: true 即可. 像这样子：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">title: &quot;在Hexo中给文章加目录(Table Of Contents)&quot;</div><div class="line">date: 2015-07-15 22:40:42</div><div class="line">tags: [Hexo]</div><div class="line">toc: true</div><div class="line">---</div></pre></td></tr></table></figure></p>
<p>修改目录样式：<br><br>/themes/yilia/source/css/_partial/article.styl中的末尾加上<br><br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.toc-article</span> &#123;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#eee</span>;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> .<span class="number">5em</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">1em</span></div><div class="line">&#125;</div><div class="line"><span class="selector-class">.toc-article</span> <span class="selector-tag">strong</span> &#123;</div><div class="line">    <span class="attribute">padding</span>: .<span class="number">3em</span> <span class="number">0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-id">#toc</span> &#123;</div><div class="line">    <span class="attribute">line-height</span>: <span class="number">1.6em</span>;</div><div class="line">    <span class="attribute">font-size</span>: .<span class="number">8em</span>;</div><div class="line">    <span class="attribute">float</span>: right</div><div class="line">&#125;</div><div class="line"><span class="selector-id">#toc</span> <span class="selector-class">.toc</span> &#123;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">0</span></div><div class="line">&#125;</div><div class="line"><span class="selector-id">#toc</span> <span class="selector-class">.toc</span> <span class="selector-tag">li</span> &#123;</div><div class="line">    <span class="attribute">list-style-type</span>: none</div><div class="line">&#125;</div><div class="line"><span class="selector-id">#toc</span> <span class="selector-tag">ol</span> &#123;</div><div class="line">    <span class="attribute">margin-left</span>: <span class="number">0</span></div><div class="line">&#125;</div><div class="line"><span class="selector-id">#toc</span> <span class="selector-class">.toc-child</span> &#123;</div><div class="line">    <span class="attribute">padding-left</span>: <span class="number">1.5em</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;&ensp;&ensp;第一段的toc-article指定了目录整个<code>&lt;div&gt;</code>的背景色、边框色、倒角半径、各种间距以及最大的宽度。注意这里最好指定目录的最大宽度，我将其设为了28%，也就是文章正文那个框的宽度的28%，也可以设为一个固定的长度，比如在笔记本电脑上16em就是个不错的宽度，但为了能适配各种不同尺寸的屏幕，最好还是设置为百分比。如果不指定最大宽度，遇到比较长的标题时，生成的目录会非常难看。这个最大宽度的设置是我在网上其他添加目录的方法中没有见到的。<br><br>&ensp;&ensp;&ensp;&ensp;第二段的toc-title指的就是“文章目录”那四个字，这四个字要比其他字大一些，将其字号设为其他字的120%。<br><br>&ensp;&ensp;&ensp;&ensp;第三段的#toc.toc指定了目录列表的一些细节，将font-size设为0.9em会让目录的字比文章的字稍小一些。最后的.toc-child指定了二级目录的缩进量。<br><br>&ensp;&ensp;&ensp;&ensp;再次生成页面，应该已经可以显示比较美观的目录<br></p>
<p><font color="red" size="4">常见错误解决：</font><br><br><a href="http://www.xyzardq.com/2016/11/14/Hexo%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" target="_blank" rel="external">参考</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FATAL (unknown path) [Line 7, Column 533]</div><div class="line">  Error: Unable to call `now`, which is undefined or falsey Template render error: (unknown path) [Line 7, Column 533]</div></pre></td></tr></table></figure></p>
<p>错误原因：<br><br>由于文章中有类似now()的结构，Hexo编译时误认为是now函数，结果找不到函数就报错了<br><br>解决：<br><br>将now( )的小括号通过<code>&amp;#40;</code> <code>&amp;#41;</code>进行转换。<br></p>
<p><font color="orange">部分插件加载失败：</font><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ERROR Plugin load failed:hexo-generator-json-content</div></pre></td></tr></table></figure></p>
<p>解决：升级nodejs<br></p>
<p><font color="orange">hexo d报错：</font><br><br>终极解决方案<br><br>1.删除根目录下的.deploy_git文件夹<br><br>2.在根目录运行hexo clean<br><br>3.修改根目录下的_config.yml后运行hexo deploy部署到云端<br></p>
<p><font color="orange">hexo g错误:</font><br><br>个人认为最大原因是配置文件出错<br><br>另附参考：<br><br><a href="http://www.voidcn.com/blog/chwshuang/article/p-6178796.html" target="_blank" rel="external">http://www.voidcn.com/blog/chwshuang/article/p-6178796.html</a><br><br><a href="https://xuanwo.org/2014/08/14/hexo-usual-problem/" target="_blank" rel="external">https://xuanwo.org/2014/08/14/hexo-usual-problem/</a><br></p>
<p><font color="red"><br>添加站点小图标<br></font><br>主题目录下/source中添加图片<br></p>
<p><font color="red">添加文章目录</font><br><br>配置中启用：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">toc:</div><div class="line">  on: true</div><div class="line">  list_number: true  #开启标题前序号</div><div class="line">  max_depth: 3  #目录最大级数，可选1-6</div><div class="line">  nowrap: false  #标题不换行</div></pre></td></tr></table></figure></p>
<p>如果要在某个文章中关闭目录，那么在md文件开头加上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">toc ：false  #关闭目录</div><div class="line">toc_list_number: false  #隐藏目录序号</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;h2&gt;&lt;center&gt;hexo主题定制2&lt;/center&gt;&lt;/h2&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=darkgreen size=5&gt;博主推荐：&lt;/font&gt;&lt;br/&gt;&lt;br&gt;&lt;a href=&quot;http://moxfive.xyz&quot;&gt;http://moxfive.xyz&lt;/a&gt;&lt;br/&gt;&lt;br&gt;&lt;a href=&quot;http://gaomf.cn&quot;&gt;http://gaomf.cn&lt;/a&gt;&lt;br/&gt;&lt;br&gt;&lt;a href=&quot;http://www.xyzardq.com&quot;&gt;http://www.xyzardq.com&lt;/a&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;hr/&gt;&lt;br&gt;&lt;br/&gt;&lt;br&gt;主题介绍：&lt;br/&gt;&lt;br&gt;Yelee:&lt;br/&gt;&lt;br&gt;&lt;a href=&quot;http://moxfive.coding.me/yelee/&quot;&gt;http://moxfive.coding.me/yelee/&lt;/a&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;hr/&gt;&lt;br&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=red size=4&gt;设置代码高亮&lt;/font&gt;&lt;br/&gt;&lt;br&gt;在反引号后面紧跟着语言名称就可以了，比如c语言&lt;br/&gt;&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;hello word\n&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在反引号后面加上c&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=red size=4&gt;添加单独页面，比如自我介绍&lt;/font&gt;&lt;br/&gt;&lt;br&gt;&amp;ensp;&amp;ensp;首先在根目录下的public/categories目录下找到相关目录，然后再添加md文件，在到主题目录下找到配置文件，在其中的menu下自定义选项，注意路径一定要正确&lt;/br&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://simonid.github.io/tags/hexo/"/>
    
      <category term="博客" scheme="https://simonid.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Linux-Command</title>
    <link href="https://simonid.github.io/2017/03/14/Linux-Command/"/>
    <id>https://simonid.github.io/2017/03/14/Linux-Command/</id>
    <published>2017-03-14T05:29:14.000Z</published>
    <updated>2017-03-14T11:21:09.000Z</updated>
    
    <content type="html"><![CDATA[<p></p><h2><center>Linux Command</center></h2><p></p>
<p><font color="red">查找相同的文件：</font><br><br>首先要下载fdupes工具:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install fdupes</div><div class="line"># yum install fdupes</div><div class="line"># dnf install fdupes //fedora22之后</div></pre></td></tr></table></figure></p>
<p><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fdupes directory/  查找目录下相同的文件</div><div class="line">fdupes directory/ -r -d 递归查找出重复名的文件，并且删除掉重复的，删除哪个文件可以根据编号确定，也可以设置范围，注意如果如果只是名字相同内容不同会导致误删。</div><div class="line">下面是别的参数：</div><div class="line">-S：显示重复文件的大小</div><div class="line">-f：忽略掉每个匹配集中的首个文件</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p><font color="red">通过名字查找进程ID</font><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps aux | awk &apos;/name/ &#123;print $2&#125;&apos;</div></pre></td></tr></table></figure></p>
<p><font color="red">以适合的方式(显示m或k…)输出当前目录下的各个子目录大小</font><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">du -h --max-depth=1</div></pre></td></tr></table></figure></p>
<p><font color="red">使用dd备份硬盘</font><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo dd -f=/dev/sda of=/media/disk/backup/sda.backup</div></pre></td></tr></table></figure></p>
<p><font color="red">创建指定大小的文件</font><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dd if=/dev/zero of=aa.txt bs=1M count=1</div></pre></td></tr></table></figure></p>
<p><font color="red">找到默认网关</font><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -rn | grep UG | tr -s &quot; &quot; | cut -d&quot; &quot; -f2</div></pre></td></tr></table></figure></p>
<p><font color="red">scp远程复制</font><br><br>格式：scp 参数 原路径 目标路径<br>参数：-v —详细显示输出的具体情况<br>     -r —递归复制整个目录<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">复制文件：</div><div class="line">scp local_file remote_username@remote_ip:remote_folder  </div><div class="line">或者  </div><div class="line">scp local_file remote_username@remote_ip:remote_file  </div><div class="line">或者  </div><div class="line">scp local_file remote_ip:remote_folder  </div><div class="line">或者  </div><div class="line">scp local_file remote_ip:remote_file</div><div class="line">注解：</div><div class="line">第1,2个指定了用户名，命令执行后需要输入用户密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名 ;</div><div class="line"></div><div class="line">第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名;</div><div class="line"></div><div class="line">复制目录：</div><div class="line">scp -r local_folder remote_username@remote_ip:remote_folder  </div><div class="line">或者  </div><div class="line">scp -r local_folder remote_ip:remote_folder</div></pre></td></tr></table></figure></p>
<p><font color="red">通过搜寻数据库快速查找文件和目录，加上-r引入正则</font><br></p>
<p><font color="red">find查找</font><br><br>格式：<br><br>find [PATH] [option] [action]<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">和时间相关的option：</div><div class="line">-mtime n ：n 为数字，意义为在 n 天之前的『一天之内』被更动过内容的档案；</div><div class="line">    -mtime +n ：列出在 n 天之前(不含 n 天本身)被更动过内容的档案档名；</div><div class="line">    -mtime -n ：列出在 n 天之内(含 n 天本身)被更动过内容的档案档名。</div><div class="line">    -newer file ：file 为一个存在的档案，列出比 file 还要新的档案档名</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">和当单权限还有名称相关的option：</div><div class="line"> -uid n ：n 为数字，这个数字是用户的账号 ID，亦即 UID</div><div class="line">    -gid n ：n 为数字，这个数字是组名的 ID，亦即 GID</div><div class="line">    -user name ：name 为使用者账号名称！例如 dmtsai</div><div class="line">    -group name：name 为组名，例如 users ；</div><div class="line">    -nouser ：寻找档案的拥有者不存在 /etc/passwd 的人！</div><div class="line">    -nogroup ：寻找档案的拥有群组不存在于 /etc/group 的档案</div></pre></td></tr></table></figure>
<p><font color="red">将deb转到rpm</font><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alien -r -c file.deb</div></pre></td></tr></table></figure></p>
<p><font color="red">curl下载命令</font><br><br>下载单个文件:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl url</div><div class="line">curl -C url //断点续传</div></pre></td></tr></table></figure></p>
<p>-o/-O选项将下载的文件重命名并保存到指定位置：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -o a.txt url</div><div class="line">curl -O url1 -O url2  //同时下载多个文件</div></pre></td></tr></table></figure></p>
<p>限制下载速度:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl --limit-rate  200k -O url</div></pre></td></tr></table></figure></p>
<p>从FTP服务器上下载或上传文件:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -u ftpuser:ftppwd -O url //下载</div><div class="line">curl -u ftpuser:ftppwd -T filename url//下载</div></pre></td></tr></table></figure></p>
<p>传递请求:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//GET</div><div class="line">curl -u username https://api.github.com/user?access_token=XXXXX</div><div class="line">//POST</div><div class="line">curl -u username --data &quot;param1=value1&amp;param2=value&quot; https://api.github.com</div><div class="line">//如果post的数据中带特殊字符要进行转义，--data-urlencode选项可以做到</div><div class="line">curl --data-urlencode &quot;value 1&quot; http://hostname.com</div><div class="line">//也可以指定一个文件，将该文件中的内容当作数据传递给服务器端</div><div class="line">curl --data @filename https://github.api.com/authorizations</div></pre></td></tr></table></figure></p>
<p>这个命令还可以设置代理等等功能<br></p>
<p><font color="red">sftp传输</font><br><br>连接上服务器:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sftp rserver_name@server_ip</div></pre></td></tr></table></figure></p>
<p>登录后可以后续操作：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sftp&gt; ls            #list directory </div><div class="line">sftp&gt; pwd           #print working directory on remote host</div><div class="line">sftp&gt; lpwd          #print working directory on local host</div><div class="line">sftp&gt; mkdir uploads     #create a new directory</div></pre></td></tr></table></figure></p>
<p>上传：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sftp&gt; put -r file</div><div class="line">//要保留修改时间、访问时间以及被传输的文件的模式，请使用 -p 标志</div><div class="line">sftp&gt; put -pr file</div></pre></td></tr></table></figure></p>
<p>下载：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sftp&gt; get -r file</div></pre></td></tr></table></figure></p>
<p>退出：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sftp&gt; bye</div><div class="line">或者</div><div class="line">sftp&gt; exit</div></pre></td></tr></table></figure></p>
<p><font color="red">找出最近修改的N个文件</font><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -1t | head -n N</div></pre></td></tr></table></figure></p>
<p><font color="red">显示所有使用tcp和udp进程</font><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -plantu</div></pre></td></tr></table></figure></p>
<p><font color="red">按照后缀查找文件</font><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//比如查找cpp和h后缀</div><div class="line">find . regex &apos;.*\(h\|cpp\)&apos;</div></pre></td></tr></table></figure></p>
<p><font color="red">输出文件指定行范围内容</font><br><br>默认head命令打印其相应文件的开头10行<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">head -n 20 file | tail  //显示10到20行内容</div></pre></td></tr></table></figure></p>
<p>另外再提一下head其他用途：<br><br>相关参数：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-q :隐藏文件名</div><div class="line">-v ：显示文件名</div><div class="line">-c N：显示前N个字节 比如head -c 20 file。另外如果是head -c -20 file就是显示除了最后20个字节以外的内容</div><div class="line">-n N：显示前N行  head -n -10 file显示最后10行内容</div></pre></td></tr></table></figure></p>
<p><font color="red"></font><br></p>
<p><font color="red"></font><br></p>
<p><font color="red"></font><br><br>参考：<a href="http://blog.csdn.net/qwe6112071/article/details/50806734" target="_blank" rel="external">http://blog.csdn.net/qwe6112071/article/details/50806734</a><br><br><a href="https://linux.cn/article-8253-1.html?utm_source=weibo&amp;utm_medium=weibo" target="_blank" rel="external">https://linux.cn/article-8253-1.html?utm_source=weibo&amp;utm_medium=weibo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;h2&gt;&lt;center&gt;Linux Command&lt;/center&gt;&lt;/h2&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=red&gt;查找相同的文件：&lt;/font&gt;&lt;br/&gt;&lt;br&gt;首先要下载fdupes工具:&lt;br/&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;sudo apt-get install fdupes&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# yum install fdupes&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# dnf install fdupes //fedora22之后&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;fdupes directory/  查找目录下相同的文件&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;fdupes directory/ -r -d 递归查找出重复名的文件，并且删除掉重复的，删除哪个文件可以根据编号确定，也可以设置范围，注意如果如果只是名字相同内容不同会导致误删。&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;下面是别的参数：&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;-S：显示重复文件的大小&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;-f：忽略掉每个匹配集中的首个文件&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://simonid.github.io/tags/Linux/"/>
    
      <category term="Linux Command" scheme="https://simonid.github.io/tags/Linux-Command/"/>
    
  </entry>
  
  <entry>
    <title>css3学习1</title>
    <link href="https://simonid.github.io/2017/03/13/css3%E5%AD%A6%E4%B9%A01/"/>
    <id>https://simonid.github.io/2017/03/13/css3学习1/</id>
    <published>2017-03-13T10:42:32.000Z</published>
    <updated>2017-03-13T15:33:23.000Z</updated>
    
    <content type="html"><![CDATA[<p></p><h2><center>CSS3学习1</center></h2><br><strong>imooc学习笔记</strong><br><br>首先放出一张盒子模型：<br><br><img src="http://phtot-1253289359.cosgz.myqcloud.com/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.JPG" alt="盒子模型"><p></p>
<p><font color="#8092ds">边框圆角效果border-radius</font><br><br>比如：border-radius:10px;所有角都使用半径为10px的圆角<br><br>boder-radius:5px 4px 3px 2px;四个半径值分别是左上角、右上角、右下角和左下角，顺时针顺序<br><br>不仅可以使用px作为单位，也可以用百分比或者em，但是兼容性不好<br></p>
<p><font color="#8092ds">圆的效果</font><br>实心上半圆：<br><br>方法：把高度(height)设为宽度（width）的一半，并且只设置左上角和右上角的半径与元素的高度一致（大于也是可以的）。<br><br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">div&#123;</div><div class="line">    height:50px;/*是width的一半*/</div><div class="line">    width:100px;</div><div class="line">    background:#9da;</div><div class="line">    border-radius:50px 50px 0 0;/*半径至少设置为height的值*/</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>实心圆：<br><br>方法：把宽度（width）与高度(height)值设置为一致（也就是正方形），并且四个圆角值都设置为它们值的一半。如下代码：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">div&#123;</div><div class="line">    height:100px;/*与width设置一致*/</div><div class="line">    width:100px;</div><div class="line">    background:#9da;</div><div class="line">    border-radius:50px;/*四个圆角值都设置为宽度或高度值的一半*/</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>左半圆：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">div&#123; </div><div class="line">    height:100px;</div><div class="line">    width:50px;</div><div class="line">    background:#9da;</div><div class="line">    border-radius:50px 0 0 50px;  &#125;</div></pre></td></tr></table></figure></p>
<p><font color="#8092ds">边框阴影box-shadow</font><br>box-shadow: X轴偏移量 Y轴偏移量 [阴影模糊半径] [阴影扩展半径] [阴影颜色] [投影方式];<br><br><img src="http://phtot-1253289359.cosgz.myqcloud.com/box-shadow.jpg" alt="参数"><br>注意：inset 可以写在参数的第一个或最后一个，其它位置是无效的。<br><br>元素设置外阴影：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.box_shadow&#123;</div><div class="line">  box-shadow:4px 2px 6px #333333; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://phtot-1253289359.cosgz.myqcloud.com/%E5%A4%96%E9%98%B4%E5%BD%B1.jpg" alt="外阴影"><br><br>元素设置内阴影：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.box_shadow&#123;</div><div class="line">  box-shadow:4px 2px 6px #333333 inset; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://phtot-1253289359.cosgz.myqcloud.com/%E5%86%85%E9%98%B4%E5%BD%B1.jpg" alt="内阴影"><br><br>添加多个阴影：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.box_shadow&#123;</div><div class="line">    box-shadow:4px 2px 6px #f00, -4px -2px 6px #000, 0px 0px 12px 5px #33CC00 inset;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://phtot-1253289359.cosgz.myqcloud.com/%E5%A4%9A%E9%98%B4%E5%BD%B1.jpg" alt="多阴影"><br></p>
<p><font color="#8932jh">1.阴影模糊半径和阴影扩展半径的区别</font><br><br>阴影模糊半径：此参数可选，只能是正值，如果为0，表示阴影不具有模糊效果，其值越大阴影边缘就越模糊<br><br>阴影扩展半径：此参数可选，其值可以是正负值，如果为正，则整个阴影都延展扩大，反之值为负数就缩小<br></p>
<p><font color="#8932jh">2.x轴偏移量和Y轴偏移量值可以设置为负数:</font><br><br>box-shadow: X轴偏移量 Y轴偏移量 [阴影模糊半径] [阴影扩展半径] [阴影颜色] [投影方式];<br><br>x轴偏移量和y轴偏移量值可以设置为负数：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.boxshadow-outset&#123;</div><div class="line">    width:100px;</div><div class="line">    height:100px;</div><div class="line">    box-shadow:-4px 4px 6px #666;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>效果：<br><br><img src="http://phtot-1253289359.cosgz.myqcloud.com/photo/%E9%98%B4%E5%BD%B12.jpg" alt="阴影2"><br><br>Y轴偏移量为负数：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.boxshadow-outset&#123;</div><div class="line">    width:100px;</div><div class="line">    height:100px;</div><div class="line">    box-shadow:4px -4px 6px #666;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://phtot-1253289359.cosgz.myqcloud.com/photo/%E9%98%B4%E5%BD%B13.jpg" alt="阴影3"></p>
<p><font color="#8092ds">边框应用图片border-image</font><br>格式：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">background:url(xx.jpg) 10px 20px no-repeat;</div></pre></td></tr></table></figure></p>
<p><img src="http://phtot-1253289359.cosgz.myqcloud.com/photo/border-image.jpg" alt="border-image"><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#border-image&#123;</div><div class="line">   background:#F4FFFA;</div><div class="line">   width:210px; height:210px; border:70px solid #ddd;</div><div class="line">   border-image:url(borderimg.png) 70 repeat  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>repeat的意思就是重复，目前因为是刚好被整除，效果看不出来。如果改下DIV的宽高，再来看重复的效果：<br><br>边角部分为裁掉了，可见repeat就是一直重复，然后超出部分剪裁掉，而且是居中开始重复。<br><br><img src="http://phtot-1253289359.cosgz.myqcloud.com/photo/borderimage3.jpg" alt="borderimage3"></p>
<p>Round 参数：Round可以理解为圆满的铺满。为了实现圆满所以会压缩（或拉伸）；<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#border-image &#123;</div><div class="line"></div><div class="line">     width:170px;</div><div class="line"></div><div class="line">     height:170px;</div><div class="line"></div><div class="line">     border:70px solid;</div><div class="line"></div><div class="line">     border-image:url(borderimg.png) 70 round;</div><div class="line"></div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://phtot-1253289359.cosgz.myqcloud.com/photo/borderimage4.jpg" alt="borderimage4"></p>
<p>streth是拉伸的意思：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">border-image:url(...)  70  stretch</div></pre></td></tr></table></figure></p>
<p><img src="http://phtot-1253289359.cosgz.myqcloud.com/photo/borderimage5.jpg" alt="borderimage5"></p>
<p>注意：Chrome下，中间部分也会被拉伸，webkit浏览器对于round属性和repeat属性似乎没有区分，显示效果是一样的。<br><br>Firefox 26.0 下是可以准确区分的。<br></p>
<p><font color="#8092ds"></font></p>
<p><font color="#8092ds"></font></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;h2&gt;&lt;center&gt;CSS3学习1&lt;/center&gt;&lt;/h2&gt;&lt;br&gt;&lt;strong&gt;imooc学习笔记&lt;/strong&gt;&lt;br/&gt;&lt;br&gt;首先放出一张盒子模型：&lt;br/&gt;&lt;br&gt;&lt;img src=&quot;http://phtot-1253289359.cosgz.myqcloud.com/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.JPG&quot; alt=&quot;盒子模型&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#8092ds&quot;&gt;边框圆角效果border-radius&lt;/font&gt;&lt;br/&gt;&lt;br&gt;比如：border-radius:10px;所有角都使用半径为10px的圆角&lt;br/&gt;&lt;br&gt;boder-radius:5px 4px 3px 2px;四个半径值分别是左上角、右上角、右下角和左下角，顺时针顺序&lt;br/&gt;&lt;br&gt;不仅可以使用px作为单位，也可以用百分比或者em，但是兼容性不好&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#8092ds&quot;&gt;圆的效果&lt;/font&gt;&lt;/br/&gt;&lt;br&gt;实心上半圆：&lt;br/&gt;&lt;br&gt;方法：把高度(height)设为宽度（width）的一半，并且只设置左上角和右上角的半径与元素的高度一致（大于也是可以的）。&lt;br/&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://simonid.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="css3" scheme="https://simonid.github.io/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>c中的void</title>
    <link href="https://simonid.github.io/2017/03/13/c%E4%B8%AD%E7%9A%84void/"/>
    <id>https://simonid.github.io/2017/03/13/c中的void/</id>
    <published>2017-03-13T09:32:40.000Z</published>
    <updated>2017-03-13T16:07:41.000Z</updated>
    
    <content type="html"><![CDATA[<p></p><h2><center>c中的void</center></h2><br>假如我们定义了一个变量(比如int a)，然后在后面没有使用，那么在编译的时候就会显示warning，要消除这个warning，我们可以用这样的格式：a=a;但是现在更流行的写法是：(void)a;<br><br>void型指针可以指向任意类型数据，也可以用任意数据类型指针对void指针赋值，比如函数：void <em> memset(void</em>buffer,intc,size_tnum); 又比如:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int *a;</div><div class="line">void *b;</div><div class="line">b=a;  //true</div><div class="line">a=b;  //error</div><div class="line">a=(int*)b; //true</div></pre></td></tr></table></figure><p></p>
<p>ANSIC标准中不能对void指针进行算术运算，比如b++，但是在GNU中却可以，因为GNU会认为void<em>和char</em>一样<br><br>任何类型的指针都可以显式转换为void类型指针，且不会丢失数据<br><br>任何表达式均可转换为 void，但 void 类型的表达式不能强制转换为其他类型。 例如，带有 void 返回类型的函数不能将其返回值强制转换为另一类型。<br></p>
<p>顺便提合法的类型强制转换：<br><br>|目标类型 |可能的源|<br>|整型     |整数类型或浮点类型，或者指向对象的指针|<br>浮点    任何算术类型<br>指向对象的指针或 (void <em>)    任何整数类型、(void </em>)、指向对象的指针或函数指针<br>函数指针    任何整数类型、指向对象的指针或函数指针<br>结构、联合或数组    无<br>Void 类型    任何类型</p>
<p>最后要指明：如果函数没有返回值或参数，一定要声明为void类型函数或者形参<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;center&gt;c中的void&lt;/center&gt;&lt;/h2&gt;&lt;br&gt;假如我们定义了一个变量(比如int a)，然后在后面没有使用，那么在编译的时候就会显示warning，要消除这个warning，我们可以用这样的格式：a=a;但是现在更流行的写法是：(void
    
    </summary>
    
    
      <category term="c" scheme="https://simonid.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>网络设备及协议</title>
    <link href="https://simonid.github.io/2017/03/13/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E5%8F%8A%E5%8D%8F%E8%AE%AE/"/>
    <id>https://simonid.github.io/2017/03/13/网络设备及协议/</id>
    <published>2017-03-13T08:54:32.000Z</published>
    <updated>2017-03-13T08:55:01.000Z</updated>
    
    <content type="html"><![CDATA[<p></p><h2><center>网络设备及协议</center></h2><br>MAC地址分类：<br><p></p>
<p><font color="red">单播MAC地址：</font>单播MAC地址唯一标识以太网上的一个终端，该地址固化在硬件(如网卡)内部。<br></p>
<p><font color="red">组播MAC地址：</font>首字节最后一位为1(通常以0x01开头)的MAC地址，标志一组设备。<br></p>
<p><font color="red">广播MAC地址：</font>48位全1的MAC地址，标志本网段内所有设备。<br><br>网络中按照大字节序传输报文(即先传输高字节)，而字节内先传输低位比特。因此，若发送的首位比特为0就是单播，否则为组播或广播。<br><br><br>MAC地址按生存期也可分为：<br></p>
<p><font color="red">动态MAC地址：</font>交换机在网络中通过数据帧学习到，有老化时间，MAC地址和端口的对应关系会随着设备所连的交换机的端口的变化而变化。交换机关电重启后会消失，需重新学习。<br></p>
<p><font color="red">静态MAC地址：</font>通过配置产生，不会被老化，MAC地址和端口的对应关系始终不变，但交换机关电重启后也会消失，需重新配置。<br></p>
<p><font color="red">永久MAC地址：</font>通过配置产生，不会被老化，MAC地址和端口的对应关系始终不变，且交换机关电重启后也不会消失。<br><br>根据OSI模型，从下到上进行阐述：<br><br><a id="more"></a></p>
<p><font color="#8943ds" size="4"><strong>集线器（Hub）：</strong></font><br><br>&ensp;&ensp;对于物理层，就是将网线集中到一起的设备，以太网集线器(HUB)从任一端口收到以太网数据帧后，都会将该帧广播到其它所有端口，如果不同端口连接的设备同时传输数据会引起冲突，故其冲突域和广播域是所有端口，既不能隔离冲突域也不能隔离广播域。<br></p>
<p><font color="#32cjkn"><strong>冲突域和广播域：</strong></font><br><br>冲突域是指网段上的一台设备发送分组时，改物理网段上其他所有设备都需要侦探它。集线器连接的各设备就是一个典型冲突域。广播域是指，网络的一组设备侦听在该网段上发送的所有广播。<br></p>
<p><font color="#8943ds" size="4"><strong>网桥和交换机(Switch)：</strong></font><br><br>都属于数据链路层，基于mac地址进行数据转发，网桥和交换机的每个物理端口属于一个冲突域，所有端口处于一个广播域，二者均能隔离冲突域但不能隔离广播域。<br><br><br>区别：<br><br>网桥主要由软件实现，交换机主要由硬件实现<br><br>网桥只有少数几个端口；交换机可以有上百个；<br><br>由于交换机才有硬件ASIC芯片进行线速转发交换，网桥速度慢于交换机。<br>网桥使用存储转发机制，等收到了全部数据才转发；交换机除了存储机制外还有直接转发机制，只需要帧头到达处理后就可以转发，也是交换机处理快于网桥的原因之一。<br><br><br>简单的说网桥就是个硬件网络协议翻译器，假设你有2台电脑，一台兼容机安装windows，一台是Apple安装OS2，那么两台电脑之间是默认网络协议是不同的<br></p>
<p><font color="#8943ds" size="4"><strong>路由器</strong></font><br><br>位于网络层，扮演三层交换机角色，可隔离冲突和广播域，每个子网就属于一个广播域，不同子网间不能发送广播，要对广播进行控制就要使用路由器（或具有路由功能的三层交换机）。可以以路由器上的LAN口为单位分割广播域。<br><br><br>路由器的基本功能是，把数据（IP 报文）传送到正确的网络，细分则包括：1、IP 数据报的转发，包括数据报的寻径和传送；2、子网隔离，抑制广播风暴；3、维护路由表，并与其它路由器交换路由信息，这是 IP 报文转发的基础；4、IP 数据报的差错处理及简单的拥塞控制；5、实现对 IP 数据报的过滤和记帐。 <br></p>
<p>最后提一下网关，网关是一个很宽泛的概念，OSI各层几乎都有网关，但是通常是指路由器。<br></p>
<p><font color="#8943ds" size="4"><strong>网关</strong></font>（协议转换器）是互连网络中操作在OSI网络层之上的具有协议转换功能设施，所以称为设施，是因为网关不一定是一台设备，有可能在一台主机中实现网关功能。<br>　　网关用于以下几种场合的异构网络互连： <br><br>　　1).异构型局域网，如互联专用交换网PBX与遵循IEEE802标准的局域网。<br><br>　　2).局域网与广域网的互联。<br><br>　　3).广域网与广域网的互联。<br><br>　　4).局域网与主机的互联（当主机的操作系统与网络操作系统不兼容时，可以通过网关连接）。<br><br>　　<font color="#dsa08"><strong>网关的分类</strong></font><br><br>　　1)协议网关：协议网关通常在使用不同协议的网络区域间做协议转换。<br><br>　　2)应用网关：应用网关是在使用不同数据格式间翻译数据的系统。<br><br>　　3)安全网关：安全网关是各种技术的融合，具有重要且独特的保护作用，其范围从协议级过滤到十分复杂的应用级过滤<br></p>
<p><br><br><br>参考：<a href="http://network.51cto.com/art/201406/443304_all.htm" target="_blank" rel="external">http://network.51cto.com/art/201406/443304_all.htm</a><br><a href="http://www.cnblogs.com/imapla/archive/2013/03/12/2955931.html" target="_blank" rel="external">http://www.cnblogs.com/imapla/archive/2013/03/12/2955931.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;h2&gt;&lt;center&gt;网络设备及协议&lt;/center&gt;&lt;/h2&gt;&lt;br&gt;MAC地址分类：&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=red&gt;单播MAC地址：&lt;/font&gt;单播MAC地址唯一标识以太网上的一个终端，该地址固化在硬件(如网卡)内部。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=red&gt;组播MAC地址：&lt;/font&gt;首字节最后一位为1(通常以0x01开头)的MAC地址，标志一组设备。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=red&gt;广播MAC地址：&lt;/font&gt;48位全1的MAC地址，标志本网段内所有设备。&lt;br/&gt;&lt;br&gt;网络中按照大字节序传输报文(即先传输高字节)，而字节内先传输低位比特。因此，若发送的首位比特为0就是单播，否则为组播或广播。&lt;br/&gt;&lt;br/&gt;&lt;br&gt;MAC地址按生存期也可分为：&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=red&gt;动态MAC地址：&lt;/font&gt;交换机在网络中通过数据帧学习到，有老化时间，MAC地址和端口的对应关系会随着设备所连的交换机的端口的变化而变化。交换机关电重启后会消失，需重新学习。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=red&gt;静态MAC地址：&lt;/font&gt;通过配置产生，不会被老化，MAC地址和端口的对应关系始终不变，但交换机关电重启后也会消失，需重新配置。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=red&gt;永久MAC地址：&lt;/font&gt;通过配置产生，不会被老化，MAC地址和端口的对应关系始终不变，且交换机关电重启后也不会消失。&lt;br/&gt;&lt;br&gt;根据OSI模型，从下到上进行阐述：&lt;br/&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="network" scheme="https://simonid.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>桥接与二层转发的概念</title>
    <link href="https://simonid.github.io/2017/03/13/%E6%A1%A5%E6%8E%A5%E4%B8%8E%E4%BA%8C%E5%B1%82%E8%BD%AC%E5%8F%91%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <id>https://simonid.github.io/2017/03/13/桥接与二层转发的概念/</id>
    <published>2017-03-13T08:51:07.000Z</published>
    <updated>2017-03-13T08:51:47.000Z</updated>
    
    <content type="html"><![CDATA[<p></p><h2><center>桥接和二层转发的概念</center></h2><p></p>
<p><font color="#8943ds" size="4"><strong>二层转发：</strong></font><br><br>&ensp;&ensp;在链路层中，根据报文的目的MAC地址来对报文进行转发，由于数据链路层位于osi模型中的第二层，所以就称为二层转发。在二层转发中，不用对报文的头部做任何修改，但是在三层转发则是根据报文的IP地址来进行转发，同时要对报文的二层头部进行修改。<br><br>&ensp;&ensp;实现机制：<br><br>学习线程和报文转发线程，二层转发只和mac地址有关，和IP无关。<br></p>
<p><font color="#8943ds" size="4"><strong>桥接的概念:</strong></font><br><br>&ensp;&ensp;把两台处于同一网段的设备通过网桥(实质就是交换机)连接在一起，网桥是一个二层转发的设备，通俗地说就是根据目的MAC地址把一台设备上的报文原封不动转发到对应的另外一台设备，网桥在整个转发过程中是透明的。<br><br><a id="more"></a></p>
<p><font color="#8943ds" size="4"><strong>FDB表:</strong></font><br><br>信息转发表的缩写，每个网桥内都会维护一张信息转发表，会定时清理这些表中数据，称为FDB表项的老化，内容包含以下信息：<br></p>
<p><font color="#0000ff">MAC：</font>设备mac地址<br></p>
<p><font color="#0000ff">port：</font>设备连接在交换机哪个接口<br><br>网桥在收到报文后根据目的MAC查到的表项就知道报文的出端口，直接转发出去。利用mac地址学习，网桥设备每接收到一个报文就会根据报文的mac地址以及报文接收端口更新FDB表<br></p>
<p><font color="red"><strong>路由桥接和中继有什么区别：</strong></font><br><br>中继：可以让一个主机路由连接多个从机路由，多路转发。需要更大内存<br><br>桥接：只能一个路由连接另外一个路由，单对单通信<br></p>
<p><font color="red"><strong>二层广播(帧广播)和三层广播(路由广播)的区别：</strong></font><br><br>举例：<br><br>三层交换机下游两个网段，对应设备为a和b，a要和b通信，过程如下：<br><br>1.首先根据网卡的ip地址和子网掩码计算出两个设备是否在一个网段，如果是就直接二层转发了，如果不是就跨网段转发<br><br>2.如果是跨网段，要将数据包发送到网关进行三层转发<br><br>3.a设备到网关的通信是二层转发，需要知道对方b的mac，所以a先读取电脑的arp缓存，看看网关ip和mac地址的关系，如果有关系就直接转发，如果没有就是用arp协议，将携带自己的ip地址和mac地址，目的地址为网关ip，mac地址为ffff-ffff-ffff的包发送给网关。网关接收到arp广播后，回复自己的mac，数据包为源网关ip和mac，目的地址为a的ip和mac。<br><br>4.a接收到数据包后将ip和mac写入arp缓存表，并直接封装数据包，三层ip头为a的ip，目的ip为b的ip，二层帧格式为a的mac，目的为网关mac<br><br>5.网关接收到a发来数据，拆包后根据目的ip进行寻址(路由表)，找到对应路径。三层交换机根据目的ip地址对本机的arp缓存表进行查找，找到ip和mac的对应关系就直接封装转发，如果没有就发送arp广播包获取目的ip的mac（只在b网段转发），b接收到之后就响应，发送自己的mac给三层交换机，和b同网段其他设备接收的话就丢弃。三层交换机知道b的包后转发包返回给b，三层数据包头为a的ip，目的ip是b的，二层数据帧包头是b网段的网关mac，目的mac为b的mac。b收到三层交换的数据包，拆包后获取数据，按照前面类似的过程通过三层交换机转发回a。<br><br></p>
<p><font color="red">前面提到的网关就是路由或者带路由功能的交换机</font><br></p>
<p>参考：<a href="http://blog.csdn.net/duhf_think/article/details/41483153" target="_blank" rel="external">http://blog.csdn.net/duhf_think/article/details/41483153</a><br><br><a href="http://bbs.51cto.com/thread-888177-1.html" target="_blank" rel="external">http://bbs.51cto.com/thread-888177-1.html</a><br><br><a href="http://iomem.com/index.php?archives/4-Ethernet-Bridges-under-Linux.html&amp;serendipity%5Bentrypage%5D=3&amp;serendipity%5Bentrypage%5D=all&amp;serendipity%5Bentrypage%5D=all" target="_blank" rel="external">http://iomem.com/index.php?archives/4-Ethernet-Bridges-under-Linux.html&amp;serendipity%5Bentrypage%5D=3&amp;serendipity%5Bentrypage%5D=all&amp;serendipity%5Bentrypage%5D=all</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;h2&gt;&lt;center&gt;桥接和二层转发的概念&lt;/center&gt;&lt;/h2&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=#8943ds size=4&gt;&lt;strong&gt;二层转发：&lt;/strong&gt;&lt;/font&gt;&lt;br/&gt;&lt;br&gt;&amp;ensp;&amp;ensp;在链路层中，根据报文的目的MAC地址来对报文进行转发，由于数据链路层位于osi模型中的第二层，所以就称为二层转发。在二层转发中，不用对报文的头部做任何修改，但是在三层转发则是根据报文的IP地址来进行转发，同时要对报文的二层头部进行修改。&lt;br/&gt;&lt;br&gt;&amp;ensp;&amp;ensp;实现机制：&lt;br/&gt;&lt;br&gt;学习线程和报文转发线程，二层转发只和mac地址有关，和IP无关。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=#8943ds size=4&gt;&lt;strong&gt;桥接的概念:&lt;/strong&gt;&lt;/font&gt;&lt;br/&gt;&lt;br&gt;&amp;ensp;&amp;ensp;把两台处于同一网段的设备通过网桥(实质就是交换机)连接在一起，网桥是一个二层转发的设备，通俗地说就是根据目的MAC地址把一台设备上的报文原封不动转发到对应的另外一台设备，网桥在整个转发过程中是透明的。&lt;br/&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="network" scheme="https://simonid.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>c中的预处理</title>
    <link href="https://simonid.github.io/2017/03/13/c%E4%B8%AD%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86/"/>
    <id>https://simonid.github.io/2017/03/13/c中的预处理/</id>
    <published>2017-03-13T05:08:30.000Z</published>
    <updated>2017-03-13T09:19:44.000Z</updated>
    
    <content type="html"><![CDATA[<p></p><h2><center>c中的预处理</center></h2><p></p>
<p><font color="red">#define的作用：</font><br><br>可以用来简化操作，交由预处理器处理速度一般要快于函数<br><br>得到一个字的高位和低位字节</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define WORD_LOW(xxx) ((byte) ((word)(xxx) &amp; 255))</div><div class="line">#define WORD_HIGH(xxx) ((byte) ((word)(xxx) &gt;&gt; 8))</div></pre></td></tr></table></figure>
<p>值得一提的是C语言下struct+typedef+函数指针可以做到面向对象的继承，重载和多态<br><br><a id="more"></a></p>
<p><font color="red">&ensp;#define&ensp;归预处理器管理，typedef归编译器管理。</font>举个例子来阐述它们之间的不同：<br><br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#define func void (*)(char)</div><div class="line">typedef void (*function)(int); //定义一个函数指针，参数类型为char，返回值是void</div><div class="line"></div><div class="line">void a(function f);  //true</div><div class="line">void b(func f);      //error</div></pre></td></tr></table></figure>
<p>取消之前的&ensp;#define&ensp;定义：&ensp;<font color="red">#undef</font>&ensp;</p>
<p><font color="red">#ifndef的作用：</font><br><br>防止头文件中相互嵌套重复定义，比如，定义了a.h文件和b.h头文件，其中在b.h中引入了a.h，然后在一个源文件d.c中同时引入了a.h和b.h，那么a.h就重复定义；了。这时候要引入#ifndef<br>格式：&ensp;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#ifndef _XXX_H</div><div class="line">#define _XXX_H</div><div class="line">...</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p><font color="red">#ifdef的作用：</font><br><br>&ensp;#ifdef&ensp;一般形式：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#ifdef macro_name</div><div class="line">　　　 代码段　1</div><div class="line">#else</div><div class="line">　　　 代码段　2</div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p>首先：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#ifdef identifier本质上等价于#if defined( identifier).</div><div class="line">#ifndef identifier本质上等价于#if !defined( identifier).</div></pre></td></tr></table></figure></p>
<p>加入在前面定义了#define  macro_name<br>那么就会执行代码段1，否则执行2.<br><br>注意无论&ensp;#define&ensp;后面的是什么(比如&ensp;#define macro_name后面无论加什么)，只要有&ensp;#define条件编译&ensp;就会执行&ensp;#ifdef&ensp;里面的代码<br>在嵌入式中的应用：<br><br>针对一些可以移植到不同平台设备的代码，你会看到类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#ifdef _ARM_</div><div class="line">#define func() armbar()</div><div class="line">#else //such as X86</div><div class="line">#define func() x86bar()</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>另外附上一个参考：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#define ABCD 2</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line"> </div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line"> </div><div class="line">#ifdef ABCD</div><div class="line">    printf(&quot;1: yes\n&quot;);</div><div class="line">#else</div><div class="line">    printf(&quot;1: no\n&quot;);</div><div class="line">#endif</div><div class="line"> </div><div class="line">#ifndef ABCD</div><div class="line">    printf(&quot;2: no1\n&quot;);</div><div class="line">#elif ABCD == 2</div><div class="line">    printf(&quot;2: yes\n&quot;);</div><div class="line">#else</div><div class="line">    printf(&quot;2: no2\n&quot;);</div><div class="line">#endif</div><div class="line"> </div><div class="line">#if !defined(DCBA) &amp;&amp; (ABCD &lt; 2*4-3)</div><div class="line">    printf(&quot;3: yes\n&quot;);</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1: yes</div><div class="line">2: yes</div><div class="line">3: yes</div></pre></td></tr></table></figure>
<p><font color="red">#if的作用：</font><br><br>它和前面提到的&ensp;#ifdef&ensp;的主要区别就是：<br><br>&ensp;#ifdef&ensp;是检查条件编译的，只要它前面有&ensp;#define&ensp;就会执行条件内的内容；<br></p>
<p>#if是当宏定义为1时才执行(当然你也可以让宏定义等于特定值执行，比如#if macro==3)，类似于if<br>可以简化前面提到的&ensp;#ifdef&ensp;的操作，怎么简化呢，比如你需要设置两个宏的判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#ifndef macro1</div><div class="line">#ifndef macro2</div><div class="line">  代码</div><div class="line">#endif</div><div class="line">#endif</div><div class="line">//当两个宏都满足才执行代码</div></pre></td></tr></table></figure>
<p>简化:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#if define(macro1)&amp;&amp;define(macro2)</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>但是简化的方法不一定适用于旧版本编译器(C99支持)，如果要兼容旧版本编译器还是用前面比较繁琐的方法。<br></p>
<p><font color="red">#error：</font><br><br>&ensp;#error&ensp;宏用于在编译时提示一个错误并且会停止编译<br><br>比如像前面的例子，我们在使用&ensp;#ifdef&ensp;检测宏是否定义的时候，可以在后面加&ensp;#error(“have not define\n”)&ensp;作为错误提示<br></p>
<p><font color="red">#和##操作符：</font><br><br>demo：<br><br>针对#举个例子：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define PRINT_INT(n) printf(#n &quot; = %d\n&quot;,n)</div></pre></td></tr></table></figure></p>
<p>当我们调用&ensp;PRINT_INT(i+j);&ensp;，就会变成&ensp;printf(“i+j””=%d\n”,i+j);&ensp;，等价于&ensp;printf(“i+j=%d\n”,i+j);&ensp;<br></p>
<p>对于&ensp;<font color="red">##</font>&ensp;：<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#define xname(n) x ## n  &lt;==&gt;</div><div class="line">//xname(2) 就展开成x4</div><div class="line">再比如：</div><div class="line">int xname(2)=10;</div><div class="line">//就展开为int x2=10；</div></pre></td></tr></table></figure>
<p>demo：<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line"> </div><div class="line">//制造函数工厂并使用之</div><div class="line">#define FUNCTION(name, a) int fun_##name(int x) &#123; return (a)*x;&#125;</div><div class="line"> </div><div class="line">FUNCTION(quadruple, 4)</div><div class="line">FUNCTION(double, 2)</div><div class="line"> </div><div class="line">#undef FUNCTION</div><div class="line">#define FUNCTION 34</div><div class="line">#define OUTPUT(a) puts( #a )</div><div class="line"> </div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    printf(&quot;quadruple(13): %d\n&quot;, fun_quadruple(13) );</div><div class="line">    printf(&quot;double(21): %d\n&quot;, fun_double(21) );</div><div class="line">    printf(&quot;%d\n&quot;, FUNCTION);</div><div class="line">    OUTPUT(million);               //注意缺少引号</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">quadruple(13): 52</div><div class="line">double(21): 42</div><div class="line">34</div><div class="line">million</div></pre></td></tr></table></figure>
<p>参考：<a href="http://zh.cppreference.com/w/c/preprocessor" target="_blank" rel="external">http://zh.cppreference.com/w/c/preprocessor</a><br><br><a href="http://blog.sina.com.cn/s/blog_4b4b54da0100r2l6.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_4b4b54da0100r2l6.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;h2&gt;&lt;center&gt;c中的预处理&lt;/center&gt;&lt;/h2&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=red&gt;#define的作用：&lt;/font&gt;&lt;br/&gt;&lt;br&gt;可以用来简化操作，交由预处理器处理速度一般要快于函数&lt;br/&gt;&lt;br&gt;得到一个字的高位和低位字节&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;#define WORD_LOW(xxx) ((byte) ((word)(xxx) &amp;amp; 255))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#define WORD_HIGH(xxx) ((byte) ((word)(xxx) &amp;gt;&amp;gt; 8))&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;值得一提的是C语言下struct+typedef+函数指针可以做到面向对象的继承，重载和多态&lt;br/&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="c" scheme="https://simonid.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Mooc_python爬虫学习</title>
    <link href="https://simonid.github.io/2017/03/10/Mooc-python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/"/>
    <id>https://simonid.github.io/2017/03/10/Mooc-python爬虫学习/</id>
    <published>2017-03-10T12:53:35.000Z</published>
    <updated>2017-03-10T16:04:07.000Z</updated>
    
    <content type="html"><![CDATA[<p></p><h2><center>Mooc_python爬虫学习</center></h2><br>&ensp;&ensp;在中国大学mooc上的python爬虫教程<br><br>爬虫设计规模介绍：<br><br>对于小型爬虫，只是少量扒取网页上的资源，使用request库就能够解决；<br>对于中型爬虫，要引入scrapy库来解决<br>对于大型爬虫，比如谷歌、百度的搜索引擎，就需要公司自身定制<br><br>&ensp;&ensp;python爬虫过度扒取网站上的资源会对网站造成不小的压力，所以有些网站会对爬虫进行限制。限制的方式：<br>1.通过识别自身允许访问的uer-agent来限制爬虫的行为(但是稍微高级的爬虫可以伪造uer-agent)<br><br>2.通过robots协议来警告用户什么资源不能扒取<br><br><a id="more"></a><p></p>
<p></p><h3>爬虫初实践：</h3><p></p>
<p><font color="#0000ff">扒取京东商品信息：</font><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import requestss</div><div class="line">url=&quot;...&quot;</div><div class="line">try:</div><div class="line">    r=requests.get(url)</div><div class="line">    r.raise_for_status()//错误就退出</div><div class="line">    r.encoding=r.apparent_encoding</div><div class="line">    print r.text[0:1000]</div><div class="line">except:</div><div class="line">    print &quot;something wrong&quot;</div></pre></td></tr></table></figure></p>
<p><font color="#0000ff">扒取亚马逊商品信息：</font><br><br>假如我们使用前面京东爬虫的方式扒取亚马逊的商品信息，就会报503错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;import requests</div><div class="line">&gt;r=requests.get(&quot;...&quot;)</div><div class="line">&gt;r.status_code()  //提示503</div></pre></td></tr></table></figure></p>
<p>下面来分析一下问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;r.encoding</div><div class="line">&apos;ISO-8859-1&apos;</div><div class="line">&gt;r.encoding=r.apparent_encoding</div><div class="line">&gt;r.text  //会提示api错误</div><div class="line">&gt;r.requests.headers  //显示python的来源，亚马逊不运行访问</div><div class="line">&gt;k=&#123;&apos;user-agent&apos;:&apos;MOzilla/5.0&apos;&#125;//伪造头</div><div class="line">&gt;url=&quot;...&quot;</div><div class="line">&gt;r.requests.get(url,headers=k)</div><div class="line">&gt;r.status_code</div><div class="line">200</div><div class="line">&gt;r.requests.headers //显示Mozilla头</div><div class="line">&gt;r.text[:500] //获取</div></pre></td></tr></table></figure></p>
<p>图片扒取：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import os</div><div class="line">&gt;&gt;&gt;import requests url=&quot;http://imgsize.ph.126.net/?enlarge=true&amp;imgurl=http://edu-image.nosdn.1</div><div class="line">27.net/9AD94813F74DFDE716B49C10A481CEE3.jpg?imageView&amp;amp;thumbnail=426y240&amp;amp;</div><div class="line">quality=100_230x130x1x95.png&quot;</div><div class="line">&gt;&gt;&gt; root=&quot;/home/simon/vscode/sublime/py/spider//&quot;</div><div class="line">&gt;&gt;&gt; path=root+url.split(&apos;/&apos;)[-1]</div><div class="line">&gt;&gt;&gt; try:</div><div class="line">...     if not os.path.exists(root):</div><div class="line">...         os.mkdir(root)</div><div class="line">...     if not os.path.exists(path):</div><div class="line">...         r=requests.get(url)</div><div class="line">...         with open(path,&apos;wb&apos;) as f:</div><div class="line">...             f.write(r.content)</div><div class="line">...             f.close()</div><div class="line">...             print &apos;save successfully&apos;</div><div class="line">...     else:</div><div class="line">...         print &apos;file already exists&apos;</div><div class="line">... except:</div><div class="line">...     print &apos;failed&apos;</div><div class="line">...     </div><div class="line">... </div><div class="line">save successfully</div></pre></td></tr></table></figure></p>
<p>最后指定的目录下保存了名为9AD94813F74DFDE716B49C10A481CEE3.jpg?imageView&amp;thumbnail=426y240&amp;<br>quality=100_230x130x1x95.png的图片</p>
<p><font color="#0000ff">BeautifulSoup的使用</font><br><br>bs4这个库可以解析html和xml，帮助我们解析链接的资源（只要是带标签的资源都能解析），假如不引入，单纯打印text文本内容的时候，会显示很多杂乱无章的信息，加入bs4可以解决<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;from bs4 import BeautifulSoup</div><div class="line">&gt;url=&quot;...&quot;</div><div class="line">&gt;r=requests.get(url)</div><div class="line">&gt;demo=r.text  //假如直接打印demo会显示和乱的内容</div><div class="line">&gt;soup=BeautifulSoup(demo,&quot;html.parser&quot;)</div><div class="line">&gt;print soup.prettify()</div></pre></td></tr></table></figure></p>
<p><font color="#0000ff">BeautifulSoup基本元素</font><br><br>bs4有4个解析器，前面提到的html解析器是其中一种<br>基本元素：<br>tag标签：最基本的信息组织单元，分别用&lt;&gt;和&lt;/&gt;表面开头和结尾<br><br>name标签：标签名字，<code>&lt;p&gt;</code>名字就是p<br><br>attributes：标签属性，字典形式组织<br><br>navigablestring：标签内非属性字符串<br><br>comment：标签内字符串注释部分<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">还是前面的例子</div><div class="line">&gt;&gt;&gt; soup.title</div><div class="line">&lt;title&gt;Python\u7f51\u7edc\u722c\u866b\u4e0e\u4fe1\u606f\u63d0\u53d6_\u4e2d\u56fd</div><div class="line">\u5927\u5b66MOOC(\u6155\u8bfe)&lt;/title&gt;</div><div class="line">&gt;&gt;&gt; tag=soup.a</div><div class="line">&gt;&gt;&gt; print tag</div><div class="line">&lt;a class=&quot;navLeft-func-f_div203_div204_a205&quot; href=&quot;http://www.icourse163.org&quot; ta</div><div class="line">rget=&quot;_top&quot;&gt;&lt;img alt=&quot;&quot; class=&quot;navLeft-func-f_div203_div204_a205_img206&quot; height=</div><div class="line">&quot;28&quot; src=&quot;http://edu-image.nosdn.127.net/C0124E0336721FF65563B76A16A8143F.png?im</div><div class="line">ageView&amp;amp;thumbnail=190y28&amp;amp;quality=100&quot; width=&quot;190&quot;/&gt;&lt;/a&gt;</div><div class="line">&gt;&gt;&gt; tag.attrs</div><div class="line">&#123;u&apos;href&apos;: u&apos;http://www.icourse163.org&apos;, u&apos;target&apos;: u&apos;_top&apos;, u&apos;class&apos;: [u&apos;navLeft</div><div class="line">-func-f_div203_div204_a205&apos;]&#125;</div><div class="line">&gt;&gt;&gt; tag.attrs[&apos;class&apos;]</div><div class="line">[u&apos;navLeft-func-f_div203_div204_a205&apos;]</div><div class="line">&gt;&gt;&gt; tag.attrs[&apos;href&apos;]</div><div class="line">u&apos;http://www.icourse163.org&apos;</div><div class="line">&gt;&gt;&gt; print soup.p.string</div><div class="line">扫码下载APP</div></pre></td></tr></table></figure></p>
<p><font color="#0000ff">通过bs4解析器获取网页上的所有链接</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">url=&quot;...&quot;</div><div class="line">from bs4 import BeautifulSoup</div><div class="line">r.requests.get(url)</div><div class="line">demo=r.text</div><div class="line">soup=BeautifulSoup(demo,&quot;html.parser&quot;)</div><div class="line">for link in soup.find_all(&apos;a&apos;):</div><div class="line">    print link.get(&apos;href&apos;)</div></pre></td></tr></table></figure></p>
<p>bs4中的find_all方法：<br>.find_all(name,attrs,recursive,string,**kwargs)<br>返回一个列表类型，存储查找结果<br>name：对标签名称的检索字符串<br>attrs：对标签属性值的检索字符串<br>recursive：是否对子孙全部检索，默认是True<br>string：&lt;&gt;…<code>&lt;/&gt;</code>中字符串区域的检索字符串</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;h2&gt;&lt;center&gt;Mooc_python爬虫学习&lt;/center&gt;&lt;/h2&gt;&lt;br&gt;&amp;ensp;&amp;ensp;在中国大学mooc上的python爬虫教程&lt;br/&gt;&lt;br&gt;爬虫设计规模介绍：&lt;br/&gt;&lt;br&gt;对于小型爬虫，只是少量扒取网页上的资源，使用request库就能够解决；&lt;br/&gt;对于中型爬虫，要引入scrapy库来解决&lt;br/&gt;对于大型爬虫，比如谷歌、百度的搜索引擎，就需要公司自身定制&lt;br/&gt;&lt;br&gt;&amp;ensp;&amp;ensp;python爬虫过度扒取网站上的资源会对网站造成不小的压力，所以有些网站会对爬虫进行限制。限制的方式：&lt;br&gt;1.通过识别自身允许访问的uer-agent来限制爬虫的行为(但是稍微高级的爬虫可以伪造uer-agent)&lt;br/&gt;&lt;br&gt;2.通过robots协议来警告用户什么资源不能扒取&lt;br/&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://simonid.github.io/tags/python/"/>
    
      <category term="spider" scheme="https://simonid.github.io/tags/spider/"/>
    
  </entry>
  
  <entry>
    <title>c语言存储空间</title>
    <link href="https://simonid.github.io/2017/03/10/c%E8%AF%AD%E8%A8%80%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4/"/>
    <id>https://simonid.github.io/2017/03/10/c语言存储空间/</id>
    <published>2017-03-09T16:03:06.000Z</published>
    <updated>2017-03-10T11:44:34.000Z</updated>
    
    <content type="html"><![CDATA[<p></p><h2><center>c语言存储空间</center></h2><p></p>
<font color="red"><h3>内存分布</h3></font><br><table><tr><td bgcolor="#7FFFD4">栈区(stack):</td></tr></table><br><font color="#0000ff">分配和释放方式：</font>有编译器自动分配和释放<br><br><font color="#0000ff">存放的内容：</font>局部变量，参数<br><br><font color="#0000ff">特点：</font>后进先出，可以用于现场保护<br><br><table><tr><td bgcolor="#7FFFD4">堆区(heap):</td></tr></table><br><font color="#0000ff">分配和释放方式：</font>用户手动分配和释放，程序退出会自动释放<br><br><font color="#0000ff">存放的内容：</font>动态分配内存的内容<br><br><font color="#0000ff">特点：</font>可以自由划分大小，可以动态调整内存大小<br><br><font color="#0000ff">堆内存申请：</font>系统有记录空闲内存地址的链表，用户申请内存的时候就会找到空间大于用户申请内存大小的节点，所以分配的地址是随机的<br><br><a id="more"></a><br><font color="#0000ff">剩余内存的处理</font>多余部分经系统重新回收放到空闲内存链表<br><br><font color="#0000ff">首地址记录大小</font>分配内存的首地址存放该堆的大小<br><br><table><tr><td bgcolor="#7FFFD4">全局区/静态区:</td></tr></table><br><font color="#0000ff">分配和释放方式：</font>编译器分配内存，程序退出时系统自动释放内存<br><br><font color="#0000ff">存放的内容：</font>全局变量，静态变量<br><br><font color="#0000ff">特点：</font>全局和静态变量都是存储在同个区，初始化的两种变量和未初始化的变量存储在不同的两个区域，但是这两个区间相邻<br><br><table><tr><td bgcolor="#7FFFD4">常量区:</td></tr></table><br><font color="#0000ff">分配和释放方式：</font>退出程序时系统自动释放<br><br><font color="#0000ff">存放内容：</font>常量<br><br><table><tr><td bgcolor="#7FFFD4">代码区:</td></tr></table><br><font color="#0000ff">分配和释放方式：</font>编译器分配，程序退出时系统自动释放<br><br><font color="#0000ff">存放内容</font>二进制代码和特殊变量<br><br><br><font color="pink">内存存放法顺序（高到低）：栈=&gt;堆=&gt;全局区=&gt;常量区=&gt;代码区</font>

<p><font color="red"><h3>变量类型</h3></font><br></p>
<p><table><tr><td bgcolor="#7FFFD4">register变量:</td></tr></table><br>使用场景:如果一个变量使用的频率很高，可以用register修饰，提高访问速度<br>–修饰限制：只有局部变量和参数可以被声明为register变量，全局变量和静态变量不可以<br>–数量限制：register修饰的变量直接存放在cpu寄存器中，资源宝贵，不可以定义太多</p>
<p><table><tr><td bgcolor="#7FFFD4">extern变量:</td></tr></table><br>&ensp;&ensp;同以外部变量只能被定义一次，声明为外部变量（就是在函数外部定义的变量），在本函数中使用。一般可以省略掉extern<br>–作用域：&ensp;&ensp;单文件：在本文件开头声明extern A，后面某行中定义int A=1；A的作用域就是本文件从开头一直到结尾。<br>多文件：在任意文件定义int A1；在本文件声明extern A，那么从当前位置到文件末尾都可以使用。<br>–存放位置：存放在全局区</p>
<p><table><tr><td bgcolor="#7FFFD4">static变量:</td></tr></table><br>&ensp;&ensp;&ensp;&ensp;静态变量，修饰符是static。（静态变量属于静态存储方式，但是属于静态存储方式的变量不一定是静态变量，比如外部变量倏然属于静态存储方式，但是不一定是静态变量，要加上static就是才能成为静态全局变量）。<br><br>&ensp;&ensp;&ensp;&ensp;局部变量经过static修饰之后就变成静态局部变量，它的生存期为整个源文件，但是作用域还是局限于本函数，只能在该函数使用，一旦退出函数，尽管变量还在，但是不能使用。<br><br>&ensp;&ensp;&ensp;&ensp;全局变量用static就是静态全局变量，原本全局变量的作用域是多个源文件，但是static修饰之后该变量值在该源文件内有效，其他源文件不能使用。<br></p>
<p><font color="red">总结</font>： 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期；把全局变量改变为静态变量 后是改变了它的作用域， 限制了它的使用范围<br><br>&ensp;&ensp;&ensp;&ensp;当static修饰函数时，函数的作用域就限制在了本文件中</p>
<p>参考：<a href="http://blog.csdn.net/shulianghan/article/details/20472269" target="_blank" rel="external">http://blog.csdn.net/shulianghan/article/details/20472269</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;h2&gt;&lt;center&gt;c语言存储空间&lt;/center&gt;&lt;/h2&gt;&lt;/p&gt;
&lt;font color=red&gt;&lt;h3&gt;内存分布&lt;/h3&gt;&lt;/font&gt;&lt;br&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#7FFFD4&gt;栈区(stack):&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;br&gt;&lt;font color=#0000ff&gt;分配和释放方式：&lt;/font&gt;有编译器自动分配和释放&lt;br/&gt;&lt;br&gt;&lt;font color=#0000ff&gt;存放的内容：&lt;/font&gt;局部变量，参数&lt;br/&gt;&lt;br&gt;&lt;font color=#0000ff&gt;特点：&lt;/font&gt;后进先出，可以用于现场保护&lt;br/&gt;&lt;br&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#7FFFD4&gt;堆区(heap):&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;br&gt;&lt;font color=#0000ff&gt;分配和释放方式：&lt;/font&gt;用户手动分配和释放，程序退出会自动释放&lt;br/&gt;&lt;br&gt;&lt;font color=#0000ff&gt;存放的内容：&lt;/font&gt;动态分配内存的内容&lt;br/&gt;&lt;br&gt;&lt;font color=#0000ff&gt;特点：&lt;/font&gt;可以自由划分大小，可以动态调整内存大小&lt;br/&gt;&lt;br&gt;&lt;font color=#0000ff&gt;堆内存申请：&lt;/font&gt;系统有记录空闲内存地址的链表，用户申请内存的时候就会找到空间大于用户申请内存大小的节点，所以分配的地址是随机的&lt;br/&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="c" scheme="https://simonid.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c和指针</title>
    <link href="https://simonid.github.io/2017/03/09/c%E5%92%8C%E6%8C%87%E9%92%88/"/>
    <id>https://simonid.github.io/2017/03/09/c和指针/</id>
    <published>2017-03-09T09:31:12.000Z</published>
    <updated>2017-03-11T06:10:05.000Z</updated>
    
    <content type="html"><![CDATA[<p></p><h3><center>C和指针</center></h3><br>&ensp;&ensp;大一学了c语言，但是发现实际上自己对c语言的掌握程度还是不足，特别是指针部分，所以再来复习一下。<br><br>&ensp;&ensp;首先指明，指针的实质是地址，如果一个变量存储了一份数据的指针，我们就称它为指针变量。在c语言中可以用一个变量来存放指针，这个变量就是指针变量，指针变量的值就是某个数据的地址。<br><br>&ensp;&ensp;假设我们有一个int型变量a，它存储的是整型数字1，并且占用0x10b的地址，另外还有一个指针变量p，它的值是0x10b，这样我们就可以说p指向了a，或者p是指向变量a的指针<br><br><a id="more"></a><p></p>
<p><font color="#999ds">定义指针变量</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">type *name;   type *name=val;</div></pre></td></tr></table></figure></p>
<p><em>表示这是一个指针变量，我们可以用</em>去获取地址上的数据，type表示该指针变量指向的数据的类型。<br><br>再举一个例子：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int a=10;</div><div class="line">int *t;</div><div class="line">int *p=&amp;a;</div><div class="line">t=&amp;a;(*t=&amp;a也是一样效果，加上*显多余，因为前面已经声明了是一个指针)</div></pre></td></tr></table></figure></p>
<p>此时，p指向a，注意p是一个指针变量，它的值应该是一个数据的地址，我们需要将变量a的地址赋予它<br>又比如：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int **p;</div><div class="line">int *a=10;</div><div class="line">*p=a;</div><div class="line">int b=9;</div><div class="line">int c=8;</div><div class="line">int *pp;</div><div class="line">*p=&amp;b;</div><div class="line">p=&amp;c;</div></pre></td></tr></table></figure></p>
<p>上面我们定义了一个二级指针，二级指针最终的指向是10，我们需要将10对应的地址（也就是a这个指针变量）赋予指针变量*p。</p>
<p>我们可以简单地总结一下指针的创建和赋值：<br>定义指针的时候必须带有<em>,让指针变量指向对应值的时候等号后面应该是一个地址。当已经定义了一个指针变量后，后面的赋值不用</em>也可以。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int x, y, *px = &amp;x, *py = &amp;y;</div><div class="line">y = *px + 5;  //表示把x的内容加5并赋给y，*px+5相当于(*px)+5</div><div class="line">y = ++*px;  //px的内容加上1之后赋给y，++*px相当于++(*px)</div><div class="line">y = *px++;  //相当于y=(*px)++</div></pre></td></tr></table></figure></p>
<p>明确概念<a href="https://www.douban.com/note/176671788/" target="_blank" rel="external">参考</a>：<br><br>&ensp;&ensp;这里分析一下静态内存，栈内存和动态分配的内存(也就是堆内存)的区别：<nr><br>&ensp;&ensp;(1) 从静态存储区域分配。在程序编译的时候内存就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。<nr><br>&ensp;&ensp;(2) 在栈上创建。在执行函数的时侯(无论何时到达一个特殊的执行点(左花括号)时，存储单元都可以在栈上被创建。出了执行点(右花括号)，这个存储单元自动被释放)，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。<br><br>&ensp;&ensp;(3) 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。<br>字符数组和字符指针的区别：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">char p[]=&quot;abc&quot;; //相当于局部变量，在堆内存存放</div><div class="line">char *p=&quot;abc&quot;;  //相当于常量，在静态内存存放</div></pre></td></tr></table></figure></nr></nr></p>
<p><font color="#999ds">指针用在参数传递</font><br><br>&ensp;&ensp;当我们在a函数定义了一对实参，然后在a函数中调用b函数（b函数中的形参来源是a函数的一对实参，并且b函数要对传入的数据进行互换），如果我们只是使用简单的变量，那么最终在a函数中不能得到互换的数据。这是因为在a函数定义局部变量的时候，实参本身会生成一份副本传入到b函数中，但是b函数在引入形参的时候实际上引用的是a函数实参的副本，在b函数中对副本进行运算之后，修改的只是副本的数据，并没有影响到实参。所以，要达到互换的目的，我们需要在函数当中引入指针的概念。<br></p>
<p><font color="red">指针参数如何传递内存?</font><br><br><a href="http://www.cnblogs.com/kaituorensheng/p/3246900.html" target="_blank" rel="external">http://www.cnblogs.com/kaituorensheng/p/3246900.html</a></p>
<p>&ensp;&ensp;如果函数的参数是一个指针，不要指望用该指针去申请动态内存。比如下面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void GetMemory(char *p, int num)</div><div class="line">&#123;</div><div class="line">    p = (char *)malloc(sizeof(char) * num);</div><div class="line">&#125;</div><div class="line">void Test(void)</div><div class="line">&#123;</div><div class="line">    char *str = NULL;</div><div class="line">    GetMemory(str, 100);    // str 仍然为 NULL </div><div class="line">    strcpy(str, &quot;hello&quot;);   // 运行错误</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;Test函数的语句GetMemory(str,200)并没有使得str获得期望的内存，str依然是NULL，why？<br>问题就在GetMemory函数上。编译器总是要为每个参数制作临时副本，指针参数p的副本设做_p，编译器是_p=p，如果函数体内（就是动态分配内存）的程序修改了_p的内容，就会导致参数p的内容作相应的修改，这就是指针可以作为输出参数的原因。在这里，_p申请了新内存，只是把_p所指向的内存地址改变了，但是p还是没有改动，所以GetMemory不能输出任何东西，而且这样很容易造成内存泄漏。<br><img src="http://i1.piimg.com/567571/7a5d7b5f32167a50.png" alt="image1"><br>开始的时候和_p都是指向同一块内存，当修改地址1的内容时，实际上也就是修改了p所指向的内存的内容，这和我们平常使用指针参数的情况是一样的。然而当我们修改_p的值时（为它分配动态内存），只是将_p指向另外一地址（地址2），而p还是指向地址1，相当于值传递，无法改变变量内容。<br>如果要用指针传递内存，我们要引用二级指针<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void GetMemory2(char **p, int num)</div><div class="line">&#123;</div><div class="line">    *p = (char *)malloc(sizeof(char) * num);</div><div class="line">&#125;</div><div class="line">void Test2(void)</div><div class="line">&#123;</div><div class="line">    char *str = NULL;</div><div class="line">    GetMemory2(&amp;str, 100);  // 注意参数是 &amp;str，而不是str</div><div class="line">    strcpy(str, &quot;hello&quot;);  </div><div class="line">    cout&lt;&lt; str &lt;&lt; endl;</div><div class="line">    free(str); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://p1.bqimg.com/567571/c62d8a1b83fda05b.png" alt="image2"></p>
<p><font color="red">sizeof和指针</font><br><br>举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">char str[]=&quot;abcd&quot;，sizeof(str)==5,str类型是char[5];</div><div class="line">sizeof(&quot;abcd&quot;)==5，因为&quot;abcd&quot;的类型是const char[5]；</div><div class="line">char str[10]=&quot;abcd&quot;，sizeof(str)==10，此时str类型是char[10];</div><div class="line">void func(char a[10],int b[20],char *p)，</div><div class="line">sizeof(a)==sizeof(b)==sizeof(p)==4，因为a的类型是char*,b的类型是int*,p的类型是char*。</div></pre></td></tr></table></figure></p>
<p><font color="red">另外我们提一下出现频率很高的const指针</font><br><br>首先先明确，const限定符修饰的变量只能被读<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const  int a=2;</div><div class="line">int b=3;</div><div class="line">a=b;  //非法</div><div class="line">b=a;   //合法</div><div class="line">extern const i;  //合法</div><div class="line">extern const int j=2;//非法，不能再次赋值</div></pre></td></tr></table></figure></p>
<p>但是，我们还是有途径修改const定义的常量的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const int i=0;</div><div class="line">int *p=(int*)&amp;i;</div><div class="line">i=10;  //通过强制类型转换，把地址赋给变量，再次修改就可以改变const常量值</div></pre></td></tr></table></figure></p>
<p>const char <em>p/char const </em>p：这个时候const用来修饰指针所指向的变量，即指针指向的内容为常量，不能修改其内容，但是可以修改其指向（地址）。当用户想要传入一个指针参数给一个外部函数时，又不想外部函数对这个参数的修改会影响到本身作用域里原先的值，而且又要让外部函数能够对这个传入的参数进行修改用在自身，那么就要引入这个概念，实际上，我们的strcpy函数原型中有一个参数就是这种格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const char *t=0;</div><div class="line">*t=1; //非法</div><div class="line">t++; //合法</div><div class="line">char *p;</div><div class="line">const char *pp=p;  //正确</div><div class="line">char **pa;</div><div class="line">const char **pt=pa;  //错误，无法从char **转换为const char **</div></pre></td></tr></table></figure></p>
<p>char *const p:这时候const修饰指针本身，指针是常量，不能修改其指向，但是可以修改其内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">char* const p=0;</div><div class="line">*p=1;  //合法</div><div class="line">p++;  //非法</div></pre></td></tr></table></figure></p>
<p>如果要设置指向和内容都不能改写，类似这样char const * const a;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//const char ** 的赋值过程  </div><div class="line">const char c1=&apos;x&apos;;  </div><div class="line">const char * p0=&amp;c1;  </div><div class="line">const char ** p1=&amp;p0;  </div><div class="line">// char ** 的赋值过程  </div><div class="line">char c2=&apos;y&apos;;  </div><div class="line">char * p2=&amp;c2;  </div><div class="line">char ** p3=&amp;p2;  </div><div class="line">char * const * p4=p3;// 注意：char * const * 就是char ** 的赋值兼容类型</div></pre></td></tr></table></figure>
<p><font color="#9032ds">形参中引用指针和引用数组</font><br><br>&ensp;&ensp;实际上，在形参中定义数组和定义指针的效果是一样的，数组作为参数传递的时候会被弱化为指针，传递进去的是数组的首元素地址</p>
<p><font color="0000ff">void <code>*</code></font><br><br>void<em>是通用指针类型，即指向void的指针，可以指向任意类型的地址。如果函数的参数和返回值可以是任意类型，就可以用void</em>作为参数或返回值。<br></p>
<p><font color="red">注意：</font><br><br>void<em>和其他类型不能相互复制，比如int</em>变量可以复制给void<em>变量，但是void</em>变量要赋值给int<em>变量就要强制转换为int</em>类型。<br>void<em>类型不能进行加减乘除运算。<br>GNU中void</em>等价与char*</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">char s[3][10],(*k)[3],*p;</div><div class="line">p=s;</div><div class="line">p=k;</div><div class="line">p=s[0]; //正确</div><div class="line">k=s;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">struct ord </div><div class="line">&#123;</div><div class="line">int x,y;&#125; dt[2]=&#123;1,2,3,4&#125;;</div><div class="line">main()</div><div class="line">&#123;struct ord *p=dt;</div><div class="line">printf(&quot;%d,&quot;,++p-&gt;x);</div><div class="line">printf(&quot;%d,&quot;,++p-&gt;y);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定义了一个结构体，里面有两个整型变量，dt是一个数组，里面有两个元素，每个元素都是一个结构体，并且对两个元素都进行初始化，第一个元素作为一个结构体里面的两个整数值为x=1，y=2，第二个为x=3，y=4</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;h3&gt;&lt;center&gt;C和指针&lt;/center&gt;&lt;/h3&gt;&lt;br&gt;&amp;ensp;&amp;ensp;大一学了c语言，但是发现实际上自己对c语言的掌握程度还是不足，特别是指针部分，所以再来复习一下。&lt;br/&gt;&lt;br&gt;&amp;ensp;&amp;ensp;首先指明，指针的实质是地址，如果一个变量存储了一份数据的指针，我们就称它为指针变量。在c语言中可以用一个变量来存放指针，这个变量就是指针变量，指针变量的值就是某个数据的地址。&lt;br/&gt;&lt;br&gt;&amp;ensp;&amp;ensp;假设我们有一个int型变量a，它存储的是整型数字1，并且占用0x10b的地址，另外还有一个指针变量p，它的值是0x10b，这样我们就可以说p指向了a，或者p是指向变量a的指针&lt;br/&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="c" scheme="https://simonid.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>了解hexo主题的布局</title>
    <link href="https://simonid.github.io/2017/03/09/%E4%BA%86%E8%A7%A3hexo%E4%B8%BB%E9%A2%98%E7%9A%84%E5%B8%83%E5%B1%80/"/>
    <id>https://simonid.github.io/2017/03/09/了解hexo主题的布局/</id>
    <published>2017-03-09T01:09:47.000Z</published>
    <updated>2017-03-09T06:02:26.000Z</updated>
    
    <content type="html"><![CDATA[<p></p><h3><center>了解hexo主题的布局</center></h3><br>很棒的一本小书：<a href="https://pengloo53.gitbooks.io/hexo/content/" target="_blank" rel="external">https://pengloo53.gitbooks.io/hexo/content/</a><br><br>&ensp;&ensp;&ensp;hexo的主题在theme目录下，以本人使用的yilia主题来说，它的一个基本内容是这样的：<p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">yilia/</div><div class="line">├── _config.yml</div><div class="line">├── languages/</div><div class="line">├── source/</div><div class="line">└── layout/</div><div class="line">    ├── _partial/</div><div class="line">    ├── _widget/</div><div class="line">    ├── archive.ejs</div><div class="line">    ├── category.ejs</div><div class="line">    ├── index.ejs</div><div class="line">    ├── layout.ejs</div><div class="line">    ├── page.ejs</div><div class="line">    ├── post.ejs</div><div class="line">    └── tag.ejs</div></pre></td></tr></table></figure>
<a id="more"></a>
<p><font size="4" color="#89qawh">文件夹的解释：</font><br></p>
<p><font size="4" color="#89dasjk">language</font><br>语言文件夹<br></p>
<p><font size="4" color="#89dasjk">layout</font><br>布局文件夹，hexo默认使用swig模板引擎，用户可以安装插件来获取EJS、Haml或Jade支持，hexo根据模板文件的扩展名来决定所使用的模板引擎，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">layout.ejs  --使用EJS</div><div class="line">layout.swig --使用swig</div></pre></td></tr></table></figure>
<p><font size="4" color="#89dasjk">source</font><br>资源文件夹，除了模板之外的文件，比如css、js都应该放在这里。如果文件或文件夹的名称以_开头或.隐藏文件就会被忽略。如果文件可以被渲染，会经过解析然后存到public目录，否则直接拷贝到public</p>
<p><font size="4" color="#89dasjk">_partial</font><br>局部模板目录，局部模板的设计可以让你在不同模板之间进行分享，比如你的header、footer等等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">partial/header.ejs</div><div class="line">&lt;h1 id=&quot;logo&quot;&gt;&lt;%= config.title %&gt;&lt;/h1&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">index.ejs</div><div class="line">&lt;%- partial(&apos;_partial/header.ejs&apos;,&#123;config.title:&apos;Hello&apos;&#125;) %&gt;</div><div class="line">&lt;div id=&quot;content&quot;&gt;Home page&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>最后生成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;h1 id=&quot;logo&quot;&gt;Hello&lt;/h1&gt;</div><div class="line">&lt;div id=&quot;content&quot;&gt;Home page&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>前面的配置还引入了局部变量的概念,局部变量就是config.title</p>
<h4>默认布局</h4><br>layout.ejs是hexo的默认布局模板文件，里面的内容：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;%- partial(&apos;_partial/head&apos;) %&gt;</div><div class="line">&lt;body&gt;</div><div class="line"></div><div class="line">  &lt;div id=&quot;container&quot;&gt;</div><div class="line">    &lt;div class=&quot;left-col&quot;&gt;</div><div class="line">    &lt;%- partial(&apos;_partial/left-col&apos;, null, &#123;cache: !config.relative_link&#125;) %&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;div class=&quot;mid-col&quot;&gt;</div><div class="line">      &lt;%- partial(&apos;_partial/mobile-nav&apos;, null, &#123;cache: !config.relative_link&#125;) %&gt;</div><div class="line">          &lt;!--是否开启最近通知--&gt;</div><div class="line">          &lt;% if(theme.recent)&#123;%&gt;</div><div class="line">          &lt;%- partial(&apos;_partial/recent&apos;,null,&#123;cache: !config.relative_link&#125;) %&gt;</div><div class="line">          &lt;% &#125; %&gt;</div><div class="line">      &lt;div class=&quot;body-wrap&quot;&gt;&lt;%- body %&gt;&lt;/div&gt;</div><div class="line">      &lt;!--&lt;%- partial(&apos;_partial/footer&apos;) %&gt;--&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;%- partial(&apos;_partial/after-footer&apos;) %&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><br><br>&ensp;&ensp;可以看到文件里面包含了许多其他模板，其中很多是来自_partial目录下的，这说明了layout.ejs就是一个完整的页面。<br>&ensp;&ensp;每个hexo站点基本可以分为<font color="#0000ff">index(首页)</font>、<font color="#0000ff">post（文章详细页）</font>、<font color="#0000ff">page（导航标签页）</font>、<font color="#0000ff">archive（归档页）</font>、<font color="#0000ff">category（类别页）</font>还有<font color="#0000ff">tag（标签页）</font>，它们都可以在layout.ejs找到对应文件。它们的每一个都是一种布局，用以替换掉前面layout.ejs文件中的<font color="#0000ff">&lt;%- body%&gt;</font>。<br>随便打开其中的一些文件，比如category.ejs和archive.ejs：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">category:</div><div class="line">&lt;%- partial(&apos;_partial/archive&apos;, &#123;pagination: config.category, index: true&#125;) %&gt;</div><div class="line"></div><div class="line">archive:</div><div class="line">&lt;%- partial(&apos;_partial/archive&apos;, &#123;pagination: config.category, index: true&#125;) %&gt;</div></pre></td></tr></table></figure><br><br>对比起来没有任何区别，都使用_partial/archive局部模块。<br><br><h4>首页布局</h4>


<p>参考：<br><a href="https://hexo.io/zh-cn/docs/themes.html" target="_blank" rel="external">hexo官方文档</a><br><a href="http://www.codeblocq.com/2016/03/Create-an-Hexo-Theme-Part-1-Index/" target="_blank" rel="external">Create an Hexo Theme - Part 1: Index</a><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;h3&gt;&lt;center&gt;了解hexo主题的布局&lt;/center&gt;&lt;/h3&gt;&lt;br&gt;很棒的一本小书：&lt;a href=&quot;https://pengloo53.gitbooks.io/hexo/content/&quot;&gt;https://pengloo53.gitbooks.io/hexo/content/&lt;/a&gt;&lt;br/&gt;&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;hexo的主题在theme目录下，以本人使用的yilia主题来说，它的一个基本内容是这样的：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;yilia/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;├── _config.yml&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;├── languages/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;├── source/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;└── layout/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ├── _partial/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ├── _widget/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ├── archive.ejs&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ├── category.ejs&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ├── index.ejs&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ├── layout.ejs&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ├── page.ejs&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ├── post.ejs&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    └── tag.ejs&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="博客" scheme="https://simonid.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="https://simonid.github.io/tags/hexo/"/>
    
      <category term="博客" scheme="https://simonid.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="theme" scheme="https://simonid.github.io/tags/theme/"/>
    
  </entry>
  
  <entry>
    <title>Text开发环境搭建</title>
    <link href="https://simonid.github.io/2017/03/08/Sublime%20Text%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://simonid.github.io/2017/03/08/Sublime Text开发环境搭建/</id>
    <published>2017-03-08T12:36:25.000Z</published>
    <updated>2017-03-08T14:44:02.000Z</updated>
    
    <content type="html"><![CDATA[<p></p><h3><center>Sublime Text开发环境搭建</center></h3><br>&nbsp;&nbsp;&emsp;Sublime text是一个很强的跨平台编辑器，如果你只认为它和普通编辑器一样那就误解了，实际上，它有很多丰富的插件，我们可以通过拓展插件的方法来搭建一个非常完备的开发环境。甚至，很多时候，它可以替代IDE的很多工作（好多IDE真的是内存杀手，尽管它们有很多功能）。<br><br><br>官网：<a href="http://www.sublimetext.com/" target="_blank" rel="external">http://www.sublimetext.com/</a><br><br>&nbsp;&nbsp;&emsp;安装插件之前，我们要先安装package control包管理器：<br>依次点开<b>view-&gt;show control</b>(快捷键 Ctrl+`),在控制台下输入:<br><br><br><a id="more"></a><p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import urllib.request,os,hashlib; h =                           &apos;df21e130d211cfc94d9b0905775a7c0f&apos; + &apos;1e3d39e33b79698005270310898eea76&apos;; pf = &apos;Package          Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)</div></pre></td></tr></table></figure>
<p>可以参考：<a href="https://packagecontrol.io/installation" target="_blank" rel="external">https://packagecontrol.io/installation</a><br><br>安装完插件管理之后，通过菜单 <strong>Preferences&gt; Package Control （快捷键 Ctrl+Shift+P） </strong>来开启安装插件，在打开的输入框中输入<strong>install</strong> ，从提示的待选项中选择<strong> Install Package</strong>。<br>这里提一下，本人在ubuntu14.04上安装sublime text3插件的时候，当进行到install package那个步骤的时候，系统提示了错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Package Control</div><div class="line"></div><div class="line">There are no packages available for installation</div><div class="line"></div><div class="line">Please see https://packagecontrol.io/docs/troubleshooting for help</div></pre></td></tr></table></figure>
<p>网络出现了问题。。。<br>解决：<br>1.在终端输入：<font color="#d2691e">dig @8.8.8.8 -t A sublime.wbond.net +noall +answer</font><br><br>然后找到类似下面的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">; &lt;&lt;&gt;&gt; DiG 9.9.5-3-Ubuntu &lt;&lt;&gt;&gt; @8.8.8.8 -t A sublime.wbond.net +noall +answer</div><div class="line">; (1 server found)</div><div class="line">;; global options: +cmd</div><div class="line">sublime.wbond.net.  82  IN  A 50.116.34.243</div></pre></td></tr></table></figure>
<p>2.后面的数字就是你需要改的host，在/etc/hosts下，填入：<br></p>
<p><font color="#d2691e">50.116.34.243 sublime.wbond.net</font><br><br>原文：<a href="http://stackoverflow.com/questions/25105139/sublime-text-2-there-are-no-packages-available-for-installation" target="_blank" rel="external">http://stackoverflow.com/questions/25105139/sublime-text-2-there-are-no-packages-available-for-installation</a><br><br>安装完毕之后可以根据Package Control Messages这个文件查看插件信息。<br>当然你也可以删除插件，在前面提到的package control中输入<b>remove package</b>，选择要删除的插件<br><br><br></p>
<p><font size="4" color="#8b008b"><b>前端的插件</b></font><br></p>
<p><font color="#0000ff">Tag:</font>Html/xml代码格式化 <br></p>
<p><font color="#0000ff">CSScomb:</font>CSS属性排序 <br></p>
<p><font color="#0000ff">JsFormat:</font>JS代码格式化 <br></p>
<p><font color="#0000ff">Emmet：</font>快速生成HTML代码段的插件 <br></p>
<p><font color="#0000ff">jQuery:</font> 智能提示jQuery代码<br></p>
<p><font color="#0000ff">HTML5:</font>HTML5 bundle <br></p>
<p><font color="#0000ff">Js​Format: </font>JS代码格式化<br></p>
<p><hr></p>
<p><font size="4" color="#8b008b"><b>PHP的插件</b></font><br></p>
<p><font color="#0000ff">sublimelinter + sublimelinter-php:</font>PHP代码语法检测，在写的时候就可以知道是否符合PHP语法，及时修改 <br></p>
<p><font color="#0000ff">SublimeCodeIntel:</font> PHP代码自动补全工具<br></p>
<p><font color="#0000ff">Xdebug Client：</font>调试插件，可以对PHP代码设置断点、单步、步入、步出、步进等调试，以及查看实时变量值 <br></p>
<p><font color="#0000ff">DocBlockr：</font> 可以自动生成PHPDoc风格的注释<br></p>
<p><hr></p>
<p><font size="4" color="#8b008b"><b>C/C++的插件</b></font><br></p>
<p><hr></p>
<p><font size="4" color="#8b008b"><b>Python的插件</b></font><br></p>
<p><hr></p>
<p><font size="4" color="#8b008b"><b>其他的插件</b></font><br></p>
<p><font color="#0000ff">Alignment:</font>代码对齐 <br></p>
<p><font color="#0000ff">Bracket​Highlighter:</font>括号高亮<br></p>
<p><font color="#0000ff">ConvertToUTF8:</font>：支持Sublime打开 GBK, BIG5, EUC-KR, EUC-JP, Shift_JIS 等编码文件的插件<br></p>
<p><font color="#0000ff">Bracket Highlighter</font>：用于匹配括号，引号和html标签。对于很长的代码很有用<br></p>
<p><font color="#0000ff">SideBar Enhancements:</font>这个插件改进了侧边栏，增加了许多侧边栏的右键功能<br></p>
<p><font color="#0000ff">Themr：</font>主题管理，切换主题的时候，不用自己修改配置文件了，用这个可以方便的切换主题 <br></p>
<p><font color="#0000ff">SFTP:</font> ftp插件<br></p>
<p><font color="#0000ff">GBK to UTF8:</font>GBK转换为UTF8 <br></p>
<p><font color="#0000ff">Clipboard History:</font>剪切板历史记录<br></p>
<p><font color="#0000ff">Git:</font>整合git<br></p>
<p><font color="#0000ff">Sublimall:</font>同步其他设备的ST<br></p>
<p><font color="#0000ff">AutoFileName:</font>补全文件路径<br></p>
<p><font color="#0000ff"></font> <br></p>
<p><font color="#0000ff"></font> <br></p>
<p><font color="#0000ff"></font> <br></p>
<p><font color="#0000ff"></font> <br></p>
<p><font color="#0000ff"></font> <br></p>
<p><font color="#0000ff"></font> <br></p>
<p>参考牛人的经验：<br><a href="https://github.com/jikeytang/sublime-text" target="_blank" rel="external">https://github.com/jikeytang/sublime-text</a><br><br><a href="http://www.awaimai.com/940.html" target="_blank" rel="external">http://www.awaimai.com/940.html</a><br><br><a href="https://segmentfault.com/a/1190000000382934" target="_blank" rel="external">https://segmentfault.com/a/1190000000382934</a><br><br><a href="http://blog.jobbole.com/79326/" target="_blank" rel="external">http://blog.jobbole.com/79326/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;h3&gt;&lt;center&gt;Sublime Text开发环境搭建&lt;/center&gt;&lt;/h3&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;emsp;Sublime text是一个很强的跨平台编辑器，如果你只认为它和普通编辑器一样那就误解了，实际上，它有很多丰富的插件，我们可以通过拓展插件的方法来搭建一个非常完备的开发环境。甚至，很多时候，它可以替代IDE的很多工作（好多IDE真的是内存杀手，尽管它们有很多功能）。&lt;br/&gt;&lt;br/&gt;&lt;br&gt;官网：&lt;a href=&quot;http://www.sublimetext.com/&quot;&gt;http://www.sublimetext.com/&lt;/a&gt;&lt;br/&gt;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;emsp;安装插件之前，我们要先安装package control包管理器：&lt;br&gt;依次点开&lt;b&gt;view-&amp;gt;show control&lt;/b&gt;(快捷键 Ctrl+`),在控制台下输入:&lt;br/&gt;&lt;br/&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="tool" scheme="https://simonid.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>HEXO主题定制</title>
    <link href="https://simonid.github.io/2017/03/08/HEXO%E4%B8%BB%E9%A2%98%E5%AE%9A%E5%88%B6/"/>
    <id>https://simonid.github.io/2017/03/08/HEXO主题定制/</id>
    <published>2017-03-08T11:06:40.000Z</published>
    <updated>2017-03-15T13:17:19.000Z</updated>
    
    <content type="html"><![CDATA[<p></p><h2><center>hexo主题定制</center></h2><p></p>
<p><hr></p>
<p><font size="3"><em><b>后续也会更新…</b></em></font></p>
<p><hr><br><br><br>其实也就是在网上找的一些定制hexo主题的链接，废话不多说，直接放出来：<br><br>通过这篇文章先大致了解Hexo的布局<a href="http://www.ituring.com.cn/article/199325" target="_blank" rel="external">初步了解Hexo站点布局</a><br><br><br><br>Landscape主题定制：<br><br><a href="http://blog.sunnyxx.com/2014/03/07/hexo_customize/" target="_blank" rel="external"><font size="4" color="#8B008B">hexo私人定制</font></a><br><br><a href="http://hialex.cn/2014/05/18/%E5%AE%9A%E5%88%B6%E8%87%AA%E5%B7%B1%E7%9A%84hexo%E4%B8%BB%E9%A2%98/" target="_blank" rel="external"><font size="4" color="#8b008b">定制自己的hexo主题</font></a><br><br><br><a href="http://www.codertian.com/2016/03/14/change-landscape-theme-by-yourself/" target="_blank" rel="external"><font size="4" color="#8b008b">【实用技能】教你定制Hexo的landscape打造自己的主题</font></a><br><a id="more"></a><br><a href="http://hanhailong.com/2015/09/17/Hexo%E4%B8%BB%E9%A2%98-%E5%9C%A8%E5%8D%9A%E5%AE%A2%E5%B7%A6%E4%B8%8A%E8%A7%92%E6%B7%BB%E5%8A%A0ForkMeOnGithub%E5%8A%9F%E8%83%BD/" target="_blank" rel="external"><font size="4" color="#8b008b">Hexo主题-在博客左上角添加ForkMeOnGithub功能</font></a><br><br><a href="http://www.yehbeats.com/2015/04/08/hexo-search/" target="_blank" rel="external"><font size="4" color="#8b008b">Yilia主题添加站内搜索功能-swiftype</font></a><br><br><a href="http://yifeng.studio/2016/09/10/Hexo-search-baidutongji-highlight/" target="_blank" rel="external"><font size="4" color="#8b008b">站内搜索(swiftpye)、百度统计、代码高亮</font> </a><br><br><a href="http://hahack.com/codes/local-search-engine-for-hexo/" target="_blank" rel="external"><font size="4" color="#8b008b">站内搜索-很全</font></a><br><br><a href="http://moxfive.xyz/2016/05/31/hexo-local-search/" target="_blank" rel="external"><font size="4" color="#8b008b">本地站内搜索-json解析(继承自前文,存在不足)</font></a><br><br><a href="http://gaomf.cn/2016/10/10/%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2Yilia%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/" target="_blank" rel="external"><font size="4" color="#8b008b">站内搜索-针对前文进一步优化</font></a><br><br><a href="http://devlu.me/2016/01/23/Hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE%E4%B9%8B-%E4%B8%BA%E8%87%AA%E5%B7%B1%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/" target="_blank" rel="external"><font size="4" color="#8b008b">站内搜索-google平台</font></a><br><br><a href="http://frankorz.com/2016/09/30/Hexo-patch/" target="_blank" rel="external"><font size="4" color="#8b008b">博客插件-字数统计、网易云音乐、更新时间</font></a><br><br><a href="http://www.voidking.com/2015/05/31/deve-hexo-theme-optimize/" target="_blank" rel="external"><font size="4" color="#8b008b">主题优化</font></a><br><br><a href="http://morningchen.com/2015/07/15/Table-Of-Contents-for-hexo/" target="_blank" rel="external"><font size="4" color="#8b008b">在Hexo中给文章加目录</font></a><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;h2&gt;&lt;center&gt;hexo主题定制&lt;/center&gt;&lt;/h2&gt;&lt;/p&gt;
&lt;p&gt;&lt;hr/&gt;&lt;/p&gt;
&lt;p&gt;&lt;font size=3&gt;&lt;em&gt;&lt;b&gt;后续也会更新…&lt;/b&gt;&lt;/em&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;hr/&gt;&lt;br&gt;&lt;br/&gt;&lt;br&gt;其实也就是在网上找的一些定制hexo主题的链接，废话不多说，直接放出来：&lt;br/&gt;&lt;br&gt;通过这篇文章先大致了解Hexo的布局&lt;a href=&quot;http://www.ituring.com.cn/article/199325&quot;&gt;初步了解Hexo站点布局&lt;/a&gt;&lt;br/&gt;&lt;br&gt;&lt;br/&gt;&lt;br&gt;Landscape主题定制：&lt;br/&gt;&lt;br&gt;&lt;a href=&quot;http://blog.sunnyxx.com/2014/03/07/hexo_customize/&quot;&gt;&lt;font size=4 color=#8B008B&gt;hexo私人定制&lt;/font&gt;&lt;/a&gt;&lt;br/&gt;&lt;br&gt;&lt;a href=&quot;http://hialex.cn/2014/05/18/%E5%AE%9A%E5%88%B6%E8%87%AA%E5%B7%B1%E7%9A%84hexo%E4%B8%BB%E9%A2%98/&quot;&gt;&lt;font size=4 color=#8b008b&gt;定制自己的hexo主题&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;br/&gt;&lt;br&gt;&lt;a href=&quot;http://www.codertian.com/2016/03/14/change-landscape-theme-by-yourself/&quot;&gt;&lt;font size=4 color=#8b008b&gt;【实用技能】教你定制Hexo的landscape打造自己的主题&lt;/font&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="博客" scheme="https://simonid.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="https://simonid.github.io/tags/hexo/"/>
    
      <category term="博客" scheme="https://simonid.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>分析openwrt内部交换机设置</title>
    <link href="https://simonid.github.io/2017/01/18/%E5%88%86%E6%9E%90openwrt%E5%86%85%E9%83%A8%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%AE%BE%E7%BD%AE/"/>
    <id>https://simonid.github.io/2017/01/18/分析openwrt内部交换机设置/</id>
    <published>2017-01-18T05:52:55.000Z</published>
    <updated>2017-01-18T17:25:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><cneter><h2>分析openwrt内部交换机设置</h2><br>先放出一张openwrt内部的网络结构图：<br><img src="http://www.wuweixin.com/wp-content/uploads/2015/12/003dXSUazy6Lmn4r2tzb9690.png" alt="openwrt"><br>上述路由是MT7620芯片<br><br></cneter></p>
<p><font color="#0000ff"><strong><br>eth0（LAN）  eth1（WAN）
</strong></font><br><br><br>路由可分成两部分，一个是路由部分，另外一个是交换机部分。一个交换机可分成6个端口，其中5个是用户可视，如上面的Port0-4，不可视的是Port5，和路由器的eth0相连。所以，家用路由多数是5口。<br>路由器上的wan和lan口其实都是一个交换机上的不同端口而已，用户可以通过VLAN技术来划分wan和lan的数目和位置，通过VLAN设置，可以对交换机进行端口隔离，抑制广播风暴。<br>通过VLAN划分，可以使eth0区分不同端口的数据包，在路由上建立起虚拟接口eth0，eth0.1，通过控制两个虚拟接口</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;cneter&gt;&lt;h2&gt;分析openwrt内部交换机设置&lt;/h2&gt;&lt;br&gt;先放出一张openwrt内部的网络结构图：&lt;br&gt;&lt;img src=&quot;http://www.wuweixin.com/wp-content/uploads/2015/12/003dXSUazy6Lmn
    
    </summary>
    
    
  </entry>
  
</feed>
